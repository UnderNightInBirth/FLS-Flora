local t = {};

local setSousaiBonus = function( addgrd = 1 )
{
	if( addgrd )
	{
		Battle_Std.GRD_AddValue( { val=2500, boundplus=1 } ); // GRD増加
	}
	BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Always, time=254, flag=_ClearFlag_ChangeMv } );
}

local addKezuriDamage = function( damage=100, vpdamage = -1 )
{
	local dmg_val = ( vpdamage > 0 && BMvEff.GRD_GetJudgeResult() > 0 )? vpdamage : damage;
	local enemy = BMvCore.GetEnemyCharaData();
	if( enemy.push() )
	{
		_dpn("削り加算:"+dmg_val);
		Battle_Std.SetKezurareDamage( dmg_val ); // 削られダメージ適用
		
		enemy.pop();
	}
}

////////////////////////////////////////////////////////////////////////
// UNIB VO
////////////////////////////////////////////////////////////////////////

t.Mv_Liberate <- 	//リベレート　ヴェールオフ
{
	function StepMode()
	{
		//print("\nStepMode");
		BMvTbl.AddLP(0,1); //モードを進める
		BMvTbl.SetLP(1,0); //カウンタをリセット
	}
	function Init_Std() //
	{
		//BMvEff.CreateObject( { mvname="Mv_Obj_LiberateKanri", datatype=0 } );
		//BMvEff.Liberate_Set(); // リベレート状態をセット
		//Battle_Std.PcAuraEffect_LiberateInit(); //ヴェールオフのオーラ
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(def_PAT_Liberate);
		

		Battle_Std.InitVector(); // ベクトル初期化
		BMvTbl.SetVector( { x=0, y=-64, addx=0, addy=0, flags=_Vector_Normal } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=def_FL_LiberateMutekiTime, muteki_dage=def_FL_LiberateMutekiTime } );
		
		BMvEff.GRD_ClearBreak( 0 ); //効果としてブレイクをクリア
		
		BMvTbl.SetPP(def_PP_Temp,0); //汎用変数初期化

		BMvTbl.SetLP(0,0); //状態
		BMvTbl.SetLP(1,0); //状態カウンタ
		BMvTbl.SetLP(2,0); //最大タメではないヴェールオフか
		//BMvTbl.SetLP(3,0); //ＩＦＸ可能条件っす？
		
		/*
		local isOverLiberate = ( BMvEff.Liberate_Get() == _SpGaugeMode_OverLiberate)? true : false;
		local enemyisDangar = false;
		local enemy = BMvCore.GetNearEnemyCharaData(); // てき
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy ); //	
				enemyisDangar = (BCMDTbl.GetHPRatio()<=30);
			BMvCore.PopCharaData(); //
		}
		if( isOverLiberate && enemyisDangar )
		{
			BMvTbl.SetLP(3,1); //IFX可能ヴェールオフですのう
		}
		*/
		
		//BMvEff.Slowmotion_Set( { time=999, power=5000 } );
		//BMvTbl.SetLP(9,0);
		
		// FrameIDメモ
		// modeメモ(LP0) ver1.02
		// 10 0 0〜8F:タメ１枚目（0F目）
		// 20 1 0〜2F:タメ２枚目
		// 30 2 0〜2F:発動直前
		// 40 3 0〜2F:爆発絵
		// xx 4 0F:エフェクト呼び出しタイミング
		// 9+3+3+3 18 +2 = 20F
		
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0);
		local cnt = BMvTbl.GetLP(1);
		//local IFX = BMvTbl.GetLP(3);
		BMvTbl.AddLP(1,1); //フレームカウント進める
	
		switch( mode ) //mode:LP0
		{
		case 0: //初期
			if( s.FrameID == 20 ) //次の絵まで進んでしまったようだ
			{
				StepMode();
			}
			else if( cnt>6 ) //ver1.02:6
			{
				//ホールドチェック
				local mask = (0<<1)|(0<<1)|(1<<2);
				if( BMvTbl.CheckButtonHold( mask ) < 100 ) //要求と一致未満
				{
					BMvTbl.SetLP(2,1); //途中で抜けたのでタメ解除済みフラグ
					StepMode();
				}
			}
			break;
		case 1: //次のタメの絵
			if( s.FrameID == 30 ) //次の絵まで進んでしまったようだ
			{
				StepMode();
			}		
			else if( cnt>1 ) //ver1.02:cnt>1
			{
				//ホールドチェック
				local mask = (0<<1)|(0<<1)|(1<<2);
				//ためてないor前の絵でタメを解除していたら抜ける
				if( BMvTbl.CheckButtonHold( mask ) < 100 || BMvTbl.GetLP(2)==1 ) //要求と一致未満orタメ解除済
				{
					BMvTbl.SetLP(2,1); //途中で抜けたのでタメ解除済みフラグ
					StepMode();
				}
				else if( cnt>12 )
				{
					_dm("ためきった");
					//タメきった
					BMvTbl.SetFinalize(512); //最大タメヴェールオフ
					BMvTbl.JumpFrameID(20); //この絵でもうちょいまって！
					StepMode();
				}
			}
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(20);
			}
			break;
		case 2: //抜け先
			if( cnt>1 ) StepMode();  //ver1.02:cnt>1　ver1.03loc:cnt>=0
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(30);
			}
			break;
		case 3: //爆発開始
			if( cnt>1 ) StepMode();  //ver1.02:cnt>1　ver1.03loc:cnt>=0
			if( cnt==0 )
			{
				BMvTbl.JumpFrameID(40);
			}
			break;
		case 4: //ベクトルあたえたり
			if( cnt>30 ) StepMode();
			if( cnt==0 )
			{
				BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
				BMvEff.Liberate_SetMinusValue( 50 );
				//BMvEff.CreateObject( { mvname="Mv_Obj_LiberateKanri", datatype=0 } ); //ヴェールオフ中持続する
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
			
				local isOverLiberate = (BMvTbl.GetPP(def_PP_VeilOffGaugeType)==1)? 1 : 0; //0:100%開放 1:200%開放
				
				local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
				local pos = 
				{
					x=0,
					y=-260,
				}
				
				if( rc.sx != _Hantei_Error ) // 存在するか
				{
					pos.x = rc.sx;
					pos.y = rc.sy;
				}
				
				//相手がのけぞり中かどうかでフラグをつける
				local enemy_isDamage = Battle_Std.CheckEnemyisDamage()? 1 : 0; //

				// if( enemy_isDamage==0 ) //生発動なら
				// {
					// //発動時に体力を消費する
					// if( isOverLiberate )
					// {
						// BMvEff.SetHpGauge( { value=def_HPV_OverLiberate } );
					// }
					// else
					// {
						// BMvEff.SetHpGauge( { value=def_HPV_Liberate } );
					// }
				// }
				
				//92:100%生
				//93:100%コンボ
				//94:200%orタメ生
				//95:200%orタメコンボ
				//96:IWX生
				//97:IWXコンボ
				
				local usepat = 92; //ヴェールオフで使うエフェクト・判定
				if( isOverLiberate ) //200%開放の時
				{
					usepat = (enemy_isDamage)? 95 : 94; //コンボ中とそれ以外で分ける
				}
				else
				{
					usepat = (enemy_isDamage)? 93 : 92; //コンボ中とそれ以外で分ける				
				}

				local vo_eff = BMvEff.CreateObject( { x=pos.x, y=pos.y, mvname="Mv_Liberate_Eff", datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
				if( vo_eff.IsDone )
				{
					BMvCore.PushCharaData( vo_eff );
						BMvTbl.SetLP(0,enemy_isDamage);
						BMvTbl.SetLP(1,isOverLiberate);
					BMvCore.PopCharaData();
				}
				
				local eff = BMvEff.CreateObject( { x=0, y=0, mvname="", datatype=1, start_pat=83, flags=_Position_ToolShift } );
				if( eff.IsDone )
				{
					BMvCore.PushCharaData( eff ); //	
						//暗転時とかは表示しないように
						BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRenderBlackOut|_ObjFlags_NoRenderOrder } );
					BMvCore.PopCharaData(); //
				}

				Battle_Std.InitVector(); //ベクトル初期化（何か残ってるとヤバそうなので）
				BMvTbl.SetVector( { x=0, y=-800, addx=0, addy=50, flags=_Vector_Div } );
				Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす				
				
			}
			break;
		case 5: //落下開始
			if( cnt==0 )
			{
				BMvTbl.SetFinalize(0); //落下Mvへ移行
			}
			break;			
		}
		if( s.isLanding ) BMvTbl.SetFinalize(256);
	}
	function Finalize_Std() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Liberate_End",[256,"Mv_Liberate_Land"],[512,"Mv_MaxLiberate"]); //デフォ,[code,mv]...
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
	}
}

t.Mv_Liberate_End <- //落下部分
{
	function Init_Std()
	{
		local vec = BMvTbl.GetVector(0);
		if( vec.y <= 0 ) //まだ上昇してるようなら下げよう
		{
			Battle_Std.InitVector(); //ベクトル初期化
			BMvTbl.SetVector( { x=0, y=0, addx=0, addy=250, flags=_Vector_Normal } );
		}
	}
	function FrameUpdate_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.isLanding ) BMvTbl.SetFinalize(256);
	}
	function Finalize_Std()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Liberate_Land"]); //デフォ,[code,mv]...	
	}
}

t.Mv_Liberate_Land <- 	//リベレート着地
{
	function Init_Std()
	{
		Battle_Std.InitVector(); //ベクトル初期化
		BMvTbl.SetPosition( { y=0 } ); //これで何とか
		BMvTbl.SetPattern(21); //着地パターンにしてしまう
		local frame = (BMvTbl.GetPP(def_PP_Temp)==1)? def_FL_LiberateHit_LandRecovery : def_FL_Liberate_LandRecovery;
		//着地パターンには進んでるだろうし、状態の移行だけ行って着地硬直を設定する
		BMvTbl.SetMoveableFlag({ move=0, time=frame, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv }); //着地硬直
	}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
}

t.Mv_Obj_LiberateKanri <-
{
	function Init_Std()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender|_ObjFlags_NoGround|_ObjFlags_ParentMove } );
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		BMvTbl.SetLP(0,0); //カウンタ初期化
	}
	function Update_Std()
	{
		local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		BMvCore.PushCharaData( p ); //	
			local ls = BMvEff.Liberate_Get();
		BMvCore.PopCharaData(); //
		
		if( ls==_SpGaugeMode_Normal || Battle_Std.CharaisKO() ) //リベレート状態ではないので終わる		
		{
			BMvTbl.SetFinalize(0);
		}
		
	}
	function FrameUpdate_Std()
	{
		local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		BMvTbl.AddLP(0,1); //1F進める
	
		BMvTbl.SetMuki( _Direction_Reverse );

		local s = BMvTbl.GetMvStatus(); // ステータス取得
		
		

		if( mvcnt%6==0 ) //気持ち軽くする
		{
			local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
			BMvCore.PushCharaData( p );
				local bs = BtlMvStd.GetBoundStatus();
				local rc = BMvEff.GetHanteiRect ( { check=[ _Hantei_Kasanari , 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
			BMvCore.PopCharaData();
			
			if( bs.isCapture )
			{
				//つかまれ中は何も生成しない
			}
			else
			{
				//つかまれ中以外は生成
				local grp_FrameID = 100+BMvEff.Random_Limit(4)*10; //100+(0,1,2)*10

				local iRnd = BMvEff.Random_Limit(100); //0〜99 基本ランダム値
				local posx = iRnd*0.5;
				local posy = -75;
				if( rc.sx != _Hantei_Error ) // 存在するか
				{
					local pos = BMvEff.Random_PointRect( { rect=rc } );
					posx = pos.x*1.2;
					posy = (pos.y-80)*0.8;
				}			
				
				//生成
				//print("\nせいせい posx:"+posx+" posy:"+posy);
				local e = BMvEff.CreateObject( { x=posx, y=posy, datatype=1, start_pat=29, flags=_Position_ToolShift } );
				local pow = 0.5;
				local vecy = (-2000 + (iRnd*11))*pow;
				local vecx = (posx*2)*pow;
				local frame = 45;
				BMvCore.PushCharaData( e );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRenderBlackOut|_ObjFlags_NoGround } );	
					BMvTbl.SetVector( { x=vecx, y=vecy, addx=0, addy=-vecy/frame, flags=_Vector_Div } );
					BMvTbl.JumpFrameID(grp_FrameID);
				BMvCore.PopCharaData(); //	
			}
		}	
	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();		
	}
}

////////////////////////////////////////////////////////////////////////
// VEIL OFF -> MAXMODE
////////////////////////////////////////////////////////////////////////

t.Mv_Convert_Object <-
{
	//LP0:予約GRD消費ストック　発動時にいくつあるか
	//LP1:SPどんだけ増えたか 見た目はいい加減でもいいから数値ある程度そろえる
	
	//LP2:毎フレームいくつ増やすか
	//LP3:変換時間
	
	function Init_Std()
	{
		// BMvTbl.SetLP(0,0);	// 発動時にいくつあるかの予約
		
		local stock = BMvTbl.GetLP(0); // BMvEff.GRD_CheckStock( { val=-1 } ); // 発動時にいくつあるか取得
		
		local isCanselCS = (BMvTbl.GetPP(def_PP_ChainShiftStatus)==1); //キャンセルチェインシフト
		local enemyisBound = Battle_Std.CheckEnemyisBound(); // 相手がやられ中かどうか

		local cs_time = stock * 25; //チェインシフト変換フレーム　個数で変化
		local sp_frameAdd = 80; //  1Fで増える量 40=4%
		
		// GRD0個でも10%ぐらいは増える。CSゲージは25Fは最低でも出現する。
		if( stock == 0 )
		{
			cs_time = 25;
			sp_frameAdd = 40;
		}

		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		
		if( isCanselCS )
		{
			if( enemyisBound ) // 相手がBound中
			{
				cs_time = cs_time * 60 / 100;
			}
			else
			{
				cs_time = cs_time * 40 / 100;
			}
			
			if( player.push() )
			{
				local use_val = def_NormalVO_MinusValue;
				switch( BMvEff.Liberate_GetType() )
				{
				case _LiberateType_Max:
					use_val = def_MaxVO_MinusValue;
					break;
				case _LiberateType_Combo:
					use_val = def_ComboVO_MinusValue;
					break;
				case _LiberateType_Normal:
				default:
					use_val = def_NormalVO_MinusValue;
					break;
				}
				
				BMvEff.Liberate_SetMinusValue( use_val/2 ); // CS中のVOの減少割合
				
				player.pop();
			}
		}
		else //ノーキャン時
		{
			if( enemyisBound ) // 相手がBound中
			{
				cs_time = cs_time * 80 / 100;
			}
			else
			{
				// sp_frameAdd = sp_frameAdd * 100 / 100;
			}		
		
			if( player.push() )
			{
				BMvEff.Liberate_SetMinusValue( 0 ); // CS中のVOの減少割合
				
				player.pop();
			}
		}
		// _dp("\n CS:"+stock+" cancel:"+isCanselCS+" bound:"+enemyisBound+" time:"+cs_time+" plus:"+(cs_time*sp_frameAdd)/100 );

		//記憶
		BMvTbl.SetLP(2, sp_frameAdd);
		BMvTbl.SetLP(3,cs_time);

		BMvEff.GRD_ClearBreak( 0 );
		BMvEff.GRD_SetConvertBreak( { time=cs_time } ); // 開始※なんか微妙に10Fぐらい長くなるようなのでLPで抜ける

		//発動時にGRDは空になります
		if( player.push() )
		{
			local stock = BMvEff.GRD_CheckStock( { val=-1 } );
			BMvEff.GRD_UseStock( { val=stock } ); // 全消費
			
			player.pop();
		}
		
		// 出力チェック
		//_dm( format( "チェインシフト開始[ stock:%d time:%d ]", stock, convert_time ) );		
	}
	function Update_Std()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount<=2 ) return; //最初ちょろっとEXSが増えてしまうのを防止
		
		//
		local isconvert = 1; // 継続中かどうか
		BMvTbl.AddLP(3,-1); //残りチェインシフト時間を減らす
		
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
	
		if( BMvTbl.GetLP(3)<0 || BMvEff.GRD_GetBreak(0) != 100 ) // チェインシフト状態でなくなる条件
		{
			if( player.push() )
			{
				local stock = BMvEff.GRD_CheckStock( { val=-1 } );
				BMvEff.GRD_UseStock( { val=stock } ); // 全部消費
				BMvEff.GRD_ClearBreak( 0 ); // クリアはされてるけど
				
				player.pop();
			}

			BMvTbl.SetFinalize(0);
			isconvert = 0; //
			//print("\n終わり");
		}

		//チェインシフトのボーナス前にタイマーチェック
		//終了条件は一応これの前にチェックする
		local rs = BMvTbl.GetMvRoundStatus();
		//print("\nrs:"+rs.TimeUpdate);
		if( rs.TimeUpdate==0 ) //タイマーが進んでいないので
		{
			//print("\nとまれ");
			//return;
		}		

		if( isconvert ) // コンバート状態継続中
		{
			// ゲージふやし
			
			local SPadd = BMvTbl.GetLP(2); //１フレームに増やす量
			
			if( player.push() )
			{
				BMvEff.SetSpGauge( { value=SPadd } ); // ＳＰを増加
				
				player.pop();
			}
			//BMvTbl.AddLP(1,-1);
			//local lp = BMvTbl.GetLP(1);
			//if( lp<=0 ) BMvTbl.SetFinalize(0);

			//local z = BMvEff.GRD_GetBreak(0);				
			//print(format(" GB:%d %d : %d",z, s.MvCount, lp));
		}

	}	
	function Finalize_Std()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate_Std()
	{
		local player = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( player.push() )
		{
			local use_val = def_NormalVO_MinusValue;
			switch( BMvEff.Liberate_GetType() )
			{
			case _LiberateType_Max:
				use_val = def_MaxVO_MinusValue;
				break;
			case _LiberateType_Combo:
				use_val = def_ComboVO_MinusValue;
				break;
			case _LiberateType_Normal:
			default:
				use_val = def_NormalVO_MinusValue;
				break;
			}
			
			BMvEff.Liberate_SetMinusValue( 50 ); // CS中のVOの減少割合
			
			player.pop();
		}
	}
}

t.Mv_MaxActivate <- 	//リベレート　ヴェールオフ
{
	function Init_Std() //
	{
		BMvEff.AddSkillCount( _SkillCount_VeilOff ); // 履歴カウンタを加算
		
		//【トロフィー】実戦でクロスキャストヴェールオフを使用した。
		// BMvTbl.Achievement_Unlock(2);
		
		Battle_Std.MoveCode.AddFlag( def_MC_EXAction ); // 行動コード(ＥＸ)を追加
		BMvTbl.SetMvAction( def_MVA_EXSystem );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(264);

		Battle_Std.InitVector(); // ベクトル初期化
		//BMvTbl.SetVector( { x=0, y=-1800, addx=0, addy=128, flags=_Vector_Div } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		
		BMvEff.GRD_ClearBreak( 0 ); //効果としてブレイクをクリア
		
		// FrameIDメモ
		// modeメモ(LP0) ver1.02
		// 10 0 0〜8F:タメ１枚目（0F目）
		// 20 1 0〜2F:タメ２枚目
		// 30 2 0〜2F:発動直前
		// 40 3 0〜2F:爆発絵
		// xx 4 0F:エフェクト呼び出しタイミング
		// 9+3+3+3 18 +2 = 20F
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		// local checkframe_20 = BMvEff.GetFrameIDNum( 20 );
		// local checkframe_30 = BMvEff.GetFrameIDNum( 30 );
		// local checkframe_40 = BMvEff.GetFrameIDNum( 40 );
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_20, rest=4 } ); // ボタン離しで飛ぶので予約
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_30, rest=6 } ); // ボタン離しで飛ぶので予約
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_40, rest=8 } ); // ボタン離しで飛ぶので予約
		
		BMvTbl.SetLP(0,0); // カウンタ
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );

		if( stock>Def_Sys_ChainShiftGRDLimit ) stock=Def_Sys_ChainShiftGRDLimit; //限界を超えないようにする（clrまでは6個制限）

		local isSuperChainShift = (stock>=6)? 1 : 0; //すごいチェインシフトの条件		
		
		local is_celes_vp = Battle_Std.GS_CheckFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルだったか
		Battle_Std.GS_DelFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルなのを消す
		if( is_celes_vp )
		{
			isSuperChainShift = 1;
		}
		
		BMvTbl.SetLP(1,isSuperChainShift); // 何もしてないようだ

		//BMvEff.GRD_SetConvertBreak( { time=0 } );
		
		BMvEff.GRD_UseStock( { val=20 } );
		
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		////CVO発動時・相手が動けないタイミングで演出
		//local enemy = BMvCore.GetEnemyCharaData();
		//if( enemy.push() )
		//{
		//	Battle_Std.DrawInActiveEffect(); // ダメそうな演出だけ入れる
		//	enemy.pop();
		//}
		
		//Battle_Std.PlayerSE_StopLastPlaySound(); // 同時押し他の技が出たり前の技の音声があるので止める
		
		BMvTbl.SetFinalizeCode(0); // 初期化
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		
		if( mvs.FrameID != 0 )
		{
			local now_fra = BMvTbl.GetLP(0);
			if( mvs.CallCount == 0 ) BMvTbl.AddLP(0,1);
			
			// local frames = [2,2,2,2,3,3,3,3,3];
			local frames = [9,8,6,3,2,3,3,2,2];
			
			local now_total = 0;
			
			if( now_fra >= frames[ mvs.DataFrame%frames.len() ] )
			{
				BMvTbl.SetLP(0,0); // カウンタ初期化
				
				if( mvs.DataFrame+1 >= frames.len() )
				{
					BMvTbl.SetFinalize( 0 ); // 足りないのでエラー回避
					return;
				}
				else
				{
					BMvTbl.Frame_Proc( 1, _ValAdd ); // 進める
				}
			}
			
			switch( Battle_Std.GetUpdateFrameID( mvs ) )
			{
			case 10:
				BMvEff.SetStopTime( { time=28 } ); //チェインシフトの時間停止
				
				local usepat = 104;//( BMvTbl.GetLP(1) )? 76 : 82; //エフェクトのパターンを決める
				BMvEff.CreateObject( { x=0, y=-300, datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
				BMvEff.CutInProc_Set({ time=[3,37,10], cutin_mv="",erasetype=0, bgtype=1 });
				
				
				if( Battle_Std.TypeSE_Play({ type="クロスキャストヴェールオフ" }) )
				{
				}
				else
				{
					Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				}
				break;
			case 20:

		
				break;
			case 40: // 開放
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="CVO" } );
				
				// 瀕死で、じゃなくて体力の割合で計算で、
				// 瀕死になっていたら共通（以前と同じ）だと、覚醒飛ばしが無くなる
				// 瀕死でのみ強いだと、一応気をつけることができる、はず

				//BMvTbl.SetVector( { y=0, addy=0, flags=_Vector_Div } );
				//local usepat = ( isDying )? 103 : 102;
				//local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_ComboVO_HitEffect", start_pat=usepat, x=0, y=-200*128 } );
				
				if( !Battle_Std.RoundisEnd() ) // KOやタイムアップ後に発動すると次のラウンドでゲージが空になってしまうので弾く
				{
					BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
					BMvEff.Liberate_SetType( _LiberateType_Combo ); // コンボヴェールオフ
				}
				
				// def_DyingComboVO_MinusValue も def_ComboVO_MinusValue も140なので意味がない
				// local useVal = ( isDying )? def_DyingComboVO_MinusValue : def_ComboVO_MinusValue;
				
				//Sets the minus val
				BMvEff.Liberate_SetMinusValue( 50 );
				
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				
				BMvEff.GRD_AddValue( { val=20000, pressure=0, boundplus=0 } );
				
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
				//BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす
				
				Battle_Std.CharaBattleActivity_Increment(90,"ヴェールオフ使用"); // CVOは別な気もするけどVOになっていることは確か
				
				// CS同様にリセット
				if( Def_Sys_CVO_ResetAnyLimit )
				{
					Battle_Std.EnemyDamageFlag_Del( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手から消す
					Battle_Std.EnemyDamageFlag_Del( def_DF_AerialJumpCanseled ); // 「エリアルジャンプキャンセルをされた」を相手から消す
				}
				break;
			}
		}
		//else
		//{
		//	BMvTbl.SetFinalize(0);
		//}
		//if( mvs.isLanding ) BMvTbl.SetFinalize(256);
		
		// 衝撃波がヒットしてたら無敵で上書きしていく
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}
	}
	//function Finalize_Std() // 
	//{
	//	Battle_Std.SwitchNextMoveTable("Mv_ComboLiberate_End",[256,"Mv_ComboLiberate_Land"]); //デフォ,[code,mv]...
	//}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
		
	}
}

// コンボＶＯ
t.Mv_MaxActivateDash <- 	//リベレート　ヴェールオフ
{
	function Init_Std() //
	{
		BMvEff.AddSkillCount( _SkillCount_VeilOff ); // 履歴カウンタを加算
		
		//【トロフィー】実戦でクロスキャストヴェールオフを使用した。
		// BMvTbl.Achievement_Unlock(2);
		
		Battle_Std.MoveCode.AddFlag( def_MC_EXAction ); // 行動コード(ＥＸ)を追加
		BMvTbl.SetMvAction( def_MVA_EXSystem );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SysAtk ); // システム的な攻撃
		Battle_Std.MoveCodeEx.AddFlag( 4, def_MC4_EnablePanishAnnounce ); //パニッシュが出る行動
	
		Battle_Std.SetCharaFlash_LiberateInit(); //光って
		
		BMvTbl.SetMuki(_Direction_Auto);
		BMvTbl.SetPattern(263);

		Battle_Std.InitVector(); // ベクトル初期化
		//BMvTbl.SetVector( { x=0, y=-1800, addx=0, addy=128, flags=_Vector_Div } );
		
		BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		
		BMvEff.GRD_ClearBreak( 0 ); //効果としてブレイクをクリア
		
		// FrameIDメモ
		// modeメモ(LP0) ver1.02
		// 10 0 0〜8F:タメ１枚目（0F目）
		// 20 1 0〜2F:タメ２枚目
		// 30 2 0〜2F:発動直前
		// 40 3 0〜2F:爆発絵
		// xx 4 0F:エフェクト呼び出しタイミング
		// 9+3+3+3 18 +2 = 20F
		
		Battle_Std.Reversal.CheckTime_DrawInfo(); // リバーサルなら文字表示
		
		if( Def_Dbg_LocalDebugScriptPath ) //ローカル環境でのデバッグ時
		{
			Battle_Std.DebugFunc.CallAtkInitScript();
		}
		
		// local checkframe_20 = BMvEff.GetFrameIDNum( 20 );
		// local checkframe_30 = BMvEff.GetFrameIDNum( 30 );
		// local checkframe_40 = BMvEff.GetFrameIDNum( 40 );
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_20, rest=4 } ); // ボタン離しで飛ぶので予約
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_30, rest=6 } ); // ボタン離しで飛ぶので予約
		// BMvCore.CallEntryBCCachePreTransfer( { pat=def_PAT_Liberate, frame=checkframe_40, rest=8 } ); // ボタン離しで飛ぶので予約
		
		BMvTbl.SetLP(0,0); // カウンタ
		
		local stock = BMvEff.GRD_CheckStock( { val=-1 } );

		if( stock>Def_Sys_ChainShiftGRDLimit ) stock=Def_Sys_ChainShiftGRDLimit; //限界を超えないようにする（clrまでは6個制限）

		local isSuperChainShift = (stock>=6)? 1 : 0; //すごいチェインシフトの条件		
		
		local is_celes_vp = Battle_Std.GS_CheckFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルだったか
		Battle_Std.GS_DelFlag( def_PP_GS_CelecVorpal ); // セレスヴォーパルなのを消す
		if( is_celes_vp )
		{
			isSuperChainShift = 1;
		}
		
		BMvTbl.SetLP(1,isSuperChainShift); // 何もしてないようだ

		//BMvEff.GRD_SetConvertBreak( { time=0 } );
		
		BMvEff.GRD_UseStock( { val=20 } );
		
		BMvTbl.SetLP(5,0); // 衝撃がヒットしたかどうか
		
		//CVO発動時・相手が動けないタイミングで演出
		//local enemy = BMvCore.GetEnemyCharaData();
		//if( enemy.push() )
		//{
		//	Battle_Std.DrawInActiveEffect(); // ダメそうな演出だけ入れる
		//	enemy.pop();
		//}
		
		Battle_Std.PlayerSE_StopLastPlaySound(); // 同時押し他の技が出たり前の技の音声があるので止める
		
		BMvTbl.SetFinalizeCode(0); // 初期化
	}
	function FrameUpdate_Std()
	{
		local mvs = BMvTbl.GetMvStatus();
		
		if( mvs.FrameID != 0 )
		{
			local now_fra = BMvTbl.GetLP(0);
			if( mvs.CallCount == 0 ) BMvTbl.AddLP(0,1);
			
			// local frames = [2,2,2,2,3,3,3,3,3];
			local frames = [9,8,6,3,2,3,3,2,2];
			
			local now_total = 0;
			
			if( now_fra >= frames[ mvs.DataFrame%frames.len() ] )
			{
				BMvTbl.SetLP(0,0); // カウンタ初期化
				
				if( mvs.DataFrame+1 >= frames.len() )
				{
					BMvTbl.SetFinalize( 0 ); // 足りないのでエラー回避
					return;
				}
				else
				{
					BMvTbl.Frame_Proc( 1, _ValAdd ); // 進める
				}
			}
			
			switch( Battle_Std.GetUpdateFrameID( mvs ) )
			{
			case 10:
				BMvEff.SetStopTime( { time=28 } ); //チェインシフトの時間停止
				
				local usepat = 104;//( BMvTbl.GetLP(1) )? 76 : 82; //エフェクトのパターンを決める
				BMvEff.CreateObject( { x=0, y=-300, datatype=1, start_pat=usepat, flags=_Position_ToolShift } );
				BMvEff.CutInProc_Set({ time=[3,37,10], cutin_mv="",erasetype=0, bgtype=1 });
				
				
				if( Battle_Std.TypeSE_Play({ type="クロスキャストヴェールオフ" }) )
				{
				}
				else
				{
					Battle_Std.TypeSE_Play({ type="ヴェールオフ" });
				}
				break;
			case 20:

		
				break;
			case 40: // 開放
				local mvs = BMvTbl.GetMvStatus();
				local isDying = ( mvs.flags & _MvStFlag_DangerHPDef )? 1 : 0; // 瀕死状態
				
				Battle_Std.SetSpHosyoHosei( { type="CVO" } );
				
				// 瀕死で、じゃなくて体力の割合で計算で、
				// 瀕死になっていたら共通（以前と同じ）だと、覚醒飛ばしが無くなる
				// 瀕死でのみ強いだと、一応気をつけることができる、はず

				//BMvTbl.SetVector( { y=0, addy=0, flags=_Vector_Div } );
				//local usepat = ( isDying )? 103 : 102;
				//local eff = BMvEff.CreateObject( { datatype=1, mvname="Mv_ComboVO_HitEffect", start_pat=usepat, x=0, y=-200*128 } );
				
				if( !Battle_Std.RoundisEnd() ) // KOやタイムアップ後に発動すると次のラウンドでゲージが空になってしまうので弾く
				{
					BMvEff.Liberate_Set(); // ヴェールオフ状態をセット
					BMvEff.Liberate_SetType( _LiberateType_Combo ); // コンボヴェールオフ
				}
				
				// def_DyingComboVO_MinusValue も def_ComboVO_MinusValue も140なので意味がない
				// local useVal = ( isDying )? def_DyingComboVO_MinusValue : def_ComboVO_MinusValue;
				
				//Sets the minus val
				BMvEff.Liberate_SetMinusValue( 50 );
				
				// ヴェールオフになった時のボーナス
				if( Def_Sys_VeilOff_GRDBonus )
				{
					local addGRD = ( isDying )? 20000 : 10000; // 増加値

					// 発動時にGRDを増加させる
					BMvEff.GRD_AddValue( { val=addGRD, pressure=0, boundplus=0 } );
					//_dp("\n addGRD:"+addGRD);
				}
				
				BMvEff.GRD_AddValue( { val=20000, pressure=0, boundplus=0 } );
				
				BMvEff.SetSpGauge( { mode=_SpGauge_UseAll } ); //ＳＰゲージ全消費
				//BMvEff.SetCamera_Quake( { type=1, time=30 } ); //画面を横に揺らす
				
				Battle_Std.CharaBattleActivity_Increment(90,"ヴェールオフ使用"); // CVOは別な気もするけどVOになっていることは確か
				
				// CS同様にリセット
				if( Def_Sys_CVO_ResetAnyLimit )
				{
					Battle_Std.EnemyDamageFlag_Del( def_DF_JumpCanseled ); // 「ジャンプキャンセルをされた」を相手から消す
					Battle_Std.EnemyDamageFlag_Del( def_DF_AerialJumpCanseled ); // 「エリアルジャンプキャンセルをされた」を相手から消す
				}
				break;
			}
		}
		//else
		//{
		//	BMvTbl.SetFinalize(0);
		//}
		//if( mvs.isLanding ) BMvTbl.SetFinalize(256);
		
		// 衝撃波がヒットしてたら無敵で上書きしていく
		if( BMvTbl.GetLP(5)==1 )
		{
			BMvEff.SetPlayerTimer( { muteki_nage=254, muteki_dage=254 } );
		}
	}
	//function Finalize_Std() // 
	//{
	//	Battle_Std.SwitchNextMoveTable("Mv_ComboLiberate_End",[256,"Mv_ComboLiberate_Land"]); //デフォ,[code,mv]...
	//}
	function Finalize_Std()
	{
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
	}
	function LastUpdate_Std()
	{
		BMvEff.SetPlayerTimer( { muteki_nage=0, muteki_dage=0 } ); //抜けるときに消す
		
	}
}

//-----------------------------------------------------------------------------
// スマートステア
//-----------------------------------------------------------------------------
t.Mv_Skill_SSRelayAtk <-
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			// スマートステア以外から出したら相手との距離を見て減速処理をする
			local isDirectSS = BMvTbl.GetLPEx(1,1); // A+Bで直接出したか
			if( isDirectSS )
			{
				local now_vec = BMvTbl.GetVector();
				local vec_x = Battle_Std.GetEnemyDistance()/8 - now_vec.x; //8F後に到達
				// _dpn("vec_x:"+vec_x);

				// 近すぎたら減速、遠かったら加速
				if( vec_x < -3500 ) vec_x = -3500;
				if( vec_x > 1000 ) vec_x = 1000;  // 十分早いのであんまり加速はしない
				BMvTbl.SetVector({ x=vec_x, flags=_VecFlag_Add });
				local xmax = now_vec.x + vec_x - 4000;
				BMvTbl.SetVector_MaxX( xmax ); // 徐々に減速するタイプなのでXMAXも更新
			}
			break;
		}
	}
}
//-----------------------------------------------------------------------------
// フォースファンクション
//-----------------------------------------------------------------------------

//t.Mv_Atk_StdBandC <-
//{
//	function Init_After()
//	{
//		Battle_Std.SetVorpalPattern( "V_B+C" );
//		
//		// 181108 弾相殺追加
//		Battle_Std.MoveCode.AddFlag( def_MC_Sousai|def_MC_Sousai_NoSubHitCount ); // 相殺が発生する
//		
//		// 181108 CS可能ならCVO可能に（iFF用）
//		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_EnableCVO_OnlyCS );
//		
//		BMvTbl.SetLP(0,0); // 飛び道具消したかどうか
//	}
//	function FrameUpdate_After() : (setSousaiBonus)
//	{
//		Battle_Std.JumpFrameID_NotHoldAllButton({ mask=(1<<1)|(1<<2), checkid=[100,200], jumpid=[101,101], endid=250 }); //ボタンホールドしてなかったらIDジャンプ
//		
//		// 181108 弾相殺追加
//		Battle_Std.CheckSousai(); // def_MC_Sousai と触れたら相殺する
//		if( BMvTbl.GetLP(0)==0 && Battle_Std.MoveCode.CheckFlag( def_MC_Sousai_EnemySubSuccess ) )
//		{
//			BMvTbl.SetLP(0,1); // 消した
//			
//			setSousaiBonus( Def_Sys_FF_RecoverGRD ); // GRD増加、空振り必殺キャンセル可能に
//		}	
//	}
//	function HitInterrupt_After() : (addKezuriDamage)
//	{
//		if( Battle_Std.CheckDamageTiming() )
//		{
//			// ヒットスロウをかける
//			BMvEff.Slowmotion_Set( { time=10, power=6666 } );
//			BMvEff.SetCamera_Quake( { type=2, time=20, } );
//		}
//		
//		if( Battle_Std.CheckGuardTiming() )
//		{
//			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
//			
//			local mvs = BMvTbl.GetMvStatus();
//			local mvs_FrameID = mvs.FrameID;
//			
//			//VP時のみ削り追加
//			if( mvs_FrameID == 500 || mvs_FrameID == 400 )
//			{
//				//IC時にさらに追加
//				local dmg_val = (mvs_FrameID == 500)? 550 : 150;
//				
//				addKezuriDamage( dmg_val );
//			}
//		}
//	}
//}

local hazienemy_shift = function()
{
	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	if( enemy.push() )
	{
		local pos = BMvTbl.GetPosition(0);
		//画面端にくっついているようなら
		if( pos.x == def_POS_GamenHajiX || pos.x == -def_POS_GamenHajiX )
		{
			//1ドット隙間作成
			BMvTbl.SetPosition( {x=10, flags=( _Position_Add | _Position_CaptureShift | _Position_ChangeMuki) } ); //
		}
		
		enemy.pop();
	}
}

//t.Mv_Atk_StdBandC <- 
//{	
//	function FrameUpdate_After() : (hazienemy_shift)
//	{
//		switch( Battle_Std.GetUpdateFrameID() )
//		{
//			case 100:
//				local e_pos = Battle_Std.GetEnemyPosition();
//				
//				BMvTbl.SetPosition( { x=e_pos.x, flags=0 } );
//				
//				if( BMvTbl.CheckStickHold( (1<<4) | (1<<1) ) )
//                {
//                    BMvTbl.JumpFrameID(110);
//                    BMvTbl.SetPosition( {x=-10, y=-40000, flags=_Position_ChangeMuki|_Position_Add } );
//                }
//                else if( BMvTbl.CheckStickHold( (1<<6)| (1<<3) ) )
//                {
//                    BMvTbl.SetPosition( { x=200*128, flags=_Position_ChangeMuki|_Position_Add } );
//                    hazienemy_shift();
//					BMvTbl.SetMuki( _Direction_Reverse );
//                }
//                else 
//                {
//                    BMvTbl.SetPosition( { x=-200*128, flags=_Position_ChangeMuki|_Position_Add } );
//                }
//				
//				break;
//		}
//	}
//}

t.Mv_Atk_StdBandC <- 
{	
	function FrameUpdate_After() : (hazienemy_shift)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
			//case 50:
			//	if( BMvTbl.CheckStickHold( (1<<4) | (1<<1) ) )
            //    {
			//		BMvTbl.SetLP(15,1); // 初段ヒットの記憶受け皿
            //    }
            //    else if( BMvTbl.CheckStickHold( (1<<6)| (1<<3) ) )
            //    {
			//		BMvTbl.SetLP(15,2); // 初段ヒットの記憶受け皿
            //    }
            //    else 
            //    {
			//		BMvTbl.SetLP(15,0); // 初段ヒットの記憶受け皿
            //    }
			//	break;
			case 100:
				local e_pos = Battle_Std.GetEnemyPosition();
				
				BMvTbl.SetPosition( { x=e_pos.x, flags=0 } );
				
				if( BMvTbl.GetLP(15)==1 )
                {
                    BMvTbl.JumpFrameID(110);
                    BMvTbl.SetPosition( {x=-10, y=e_pos.y-40000, flags=_Position_ChangeMuki|_Position_Add } );
                }
                else if( BMvTbl.GetLP(15)==2 )
                {
                    BMvTbl.SetPosition( { x=200*128, flags=_Position_ChangeMuki|_Position_Add } );
                    hazienemy_shift();
					BMvTbl.SetMuki( _Direction_Reverse );
                }
                else 
                {
                    BMvTbl.SetPosition( { x=-200*128, flags=_Position_ChangeMuki|_Position_Add } );
					BMvTbl.SetLP(15,0); // 初段ヒットの記憶受け皿
                }
				break;
		}
	}
	function LastUpdate_After()
	{
		BMvTbl.SetLP(15,0); // 初段ヒットの記憶受け皿
	}
}

//-----------------------------------------------------------------------------
// 2+B+C
//-----------------------------------------------------------------------------

local maketmpl_SkillCrossBlade = function( param={} ) : (setSousaiBonus)
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		ball_st = {},
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.ball_st = {
			[100] = { x= 50, y=-130, mv="Mv_FireBall_CroBandC1", pat = "FB_CroBandC1",flags=def_BallFlags_NoAddHitComboRate },
			[110] = { x=100, y=-130, mv="Mv_FireBall_CroBandC2", pat = "FB_CroBandC2",flags=def_BallFlags_NoAddHitComboRate },
			[200] = { x=100, y=-130, mv="Mv_FireBall_CroBandC3", pat = "FB_CroBandC3",flags=def_BallFlags_NoAddHitComboRate },
		}
		break;
	}

	ret_tmpl.Init_After <- function() : (mvparam)
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		
		Battle_Std.MoveCode.AddFlag( def_MC_Sousai|def_MC_Sousai_NoSubHitCount ); // 相殺が発生する
		
		BMvTbl.SetPP( def_PP_Hyd_CrossBladeAddst,0); // 派生指示出しを初期化
		
		BMvTbl.SetLP(0,0); // 初段ヒットの記憶受け皿
		BMvTbl.SetLP(1,0); // 飛び道具消したかどうか
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam, setSousaiBonus)
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<1)|(1<<2), CheckFrameID=150, EndFrameID=160, SetPattern="2+B+C_End", flags=Def_JFIDNHB_CheckAllButton } ); // ButtonMask, CheckFrameID, SetPattern
		
		Battle_Std.CheckSousai(); // def_MC_Sousai と触れたら相殺する
		if( BMvTbl.GetLP(1)==0 && Battle_Std.MoveCode.CheckFlag( def_MC_Sousai_EnemySubSuccess ) )
		{
			BMvTbl.SetLP(1,1); // 消した
		}	
		
		local update_id = Battle_Std.GetUpdateFrameID();
		switch( update_id )
		{
		case 100: // １回目斬り
		case 110: // ２回目斬り
		case 200: // タメ２回目斬り
			local hit_st = BMvTbl.GetLP(0); // 初段ヒット情報
			BMvTbl.SetPP( def_PP_Hyd_CrossBladeAddst,update_id);
			if( update_id in mvparam.ball_st )
			{
				local ball = Battle_Std.CreateFireBall( mvparam.ball_st[update_id] );
				if( ball.push() )
				{
					// _dpn("update_id:"+update_id+" hit_st:"+hit_st);
					BMvTbl.SetLP(0,hit_st); // ヒット情報伝えておく
					ball.pop();
				}
			}
			// １回目斬りで弾相殺していた場合、２回目斬りのタイミングでsetSousaiBonus()する
			if( update_id == 110 || update_id == 200 ) // ２回目斬り
			{
				if( BMvTbl.GetLP(1)==1 && Battle_Std.MoveCode.CheckFlag( def_MC_Sousai_EnemySubSuccess ) ) // 弾相殺していた
				{
					setSousaiBonus( Def_Sys_FF_RecoverGRD ); // GRD増加、空振り必殺キャンセル可能に
				}
			}
			break;
		}
	}	
	
	return ret_tmpl;
}

t.Mv_Atk_CroBandC <- maketmpl_SkillCrossBlade( { type="A" } );

//FireBallの仕様メモ
//Patの頭でヒット数が0だと処理がまともに動かない

t.Mv_FireBall_CroBandC1 <-
{
	flags=def_FBTmplFlags_NewTypeFireBall,
	function FrameUpdate_After()
	{
		local add_st = BMvTbl.GetPP(def_PP_Hyd_CrossBladeAddst);
		// _dpn("add_st:"+add_st);
		if( add_st != 100 )
		{
			if( BMvTbl.GetMvStatus().FrameID != 900 )
			{
				BMvTbl.JumpFrameID(900);
			}
		}
	}
	function AtkCountZero()
	{
	}
	function Sousai()
	{
		// 一方的な相殺で消滅しない
	}
	function Blocked()
	{
		BMvTbl.JumpFrameID(900);
	}
	function HitTiming()
	{
		if( BMvTbl.CheckMvUniqueID( { datatype=_DataType_Parent } ) != 0 )
		{
			local oya = BMvCore.GetParentCharaData();
			if( oya.push() )
			{
				BMvTbl.SetLP(0,1); // 初段ヒットの記憶受け皿
				oya.pop();
			}
		}
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 25, 50 ); //削りダメージ加算　通常, VP
		}
	}
}

t.Mv_FireBall_CroBandC2 <- 
{
	flags=def_FBTmplFlags_NewTypeFireBall,
	function Init_After()
	{
		local hit_st = BMvTbl.GetLP(0);
		if( hit_st != 0 ) // 初段あたってたら1ヒット消費する
		{
			BMvTbl.CalcHitValue(-1);
		}
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 25, 50 ); //削りダメージ加算　通常, VP
		}
	}
	function AtkCountZero()
	{
		BMvTbl.JumpFrameID(900);
	}
	function Sousai()
	{
	}
	function Blocked()
	{
		BMvTbl.JumpFrameID(900);
	}
}

t.Mv_FireBall_CroBandC3 <- 
{
	flags=def_FBTmplFlags_NewTypeFireBall,
	function Init_After()
	{
		local hit_st = BMvTbl.GetLP(0);
		if( hit_st != 0 ) // 初段あたってたら1ヒット消費する
		{
			BMvTbl.CalcHitValue(-1);
		}
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 25, 50 ); //削りダメージ加算　通常, VP
		}
	}
	function AtkCountZero()
	{
		BMvTbl.JumpFrameID(900);
	}
	function Sousai()
	{
	}
	function Blocked()
	{
		BMvTbl.JumpFrameID(900);
	}
}


//-----------------------------------------------------------------------------
// イベント
//-----------------------------------------------------------------------------

t.Mv_Startup <-
{
	function Init_After()
	{
		BMvTbl.SetLP(10,0); // worlds worst timer
		Battle_Std.CreateObjectEX( { x=0, y=-10000000, mvname="Mv_INB", LP={ slot=0, val=4 } } ); // wtf
	}
}

t.Mv_INB <-
{
	function FrameUpdate_After()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			// Battle_Std.PcAuraEffect_CommonAuraSet( { type=0, time=1, power=1.0, color=0x000055AA, colorB=0x00000000, blendmode=0 } );
			BMvEff.PcAuraEffect_Set( { type=0, time=1, power=1.5, color=0x00000000, colorB=0x88FF44FF, color_chara=0x00000000 } );
			local vorpal = BMvEff.GRD_GetJudgeResult() > 0 ? 1 : 0; 
			
			BMvEff.Liberate_SetMinusValue( 120 );
			if(vorpal)
			{
				BMvEff.SetSpGauge( { value=19, } );
				BMvEff.Liberate_SetMinusValue( 30 );
			}
		}
		
		BMvTbl.AddLP(10,1);
		
		if (BMvTbl.GetLP(10) % 9 == 0)
		{
            Battle_Std.CreateObjectEX( { y = 26000, angle=2500, datatype=1, pat=31, flags=_Position_ToolShift } );
            Battle_Std.CreateObjectEX( { y = 24000, angle=-2500, datatype=1, pat=31, flags=_Position_ToolShift } );
			// Battle_Std.CreateObjectEX( { x = -230, y = -100, angle=2500, datatype=1, pat=126, flags=_Position_ToolShift } );
			// Battle_Std.CreateObjectEX( { y = -220, datatype=1, pat=188, flags=_Position_ToolShift } );
			Battle_Std.CreateObjectEX( { x = BMvEff.Random_Limit(180) - 100, y = BMvEff.Random_Limit(300)-320, datatype=1, pat=BMvEff.Random_Limit(1)+616, flags=_Position_ToolShift } );
			Battle_Std.CreateObjectEX( { x = BMvEff.Random_Limit(180) - 100, y = BMvEff.Random_Limit(300)-320, datatype=1, pat=BMvEff.Random_Limit(1)+196, flags=_Position_ToolShift } );
		}
	}
}


t.Mv_Convert <-
{
	function Init_After()
	{
		local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=_HanteiFlag_NoMukiChange | _HanteiFlag_Tool  } );
		if( rc.sx != _Hantei_Error )
		{
			BMvEff.CreateObject( { x=rc.sx, y=rc.sy, datatype=1, start_pat=104, flags=_Position_ToolShift } );
		}
	}
}

// Cutin
t.Mv_ComboLiberate <- 	//Veil Off Combo
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 40:
			local eff = Battle_Std.CreateObjectEX( { datatype=0, pat=995 } );
			if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
					BMvTbl.SetPosition( { x=-32*128, y=-270*128 } );	
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoCamera } );
					BMvEff.SetExist( { level = _Exist_NoHantei } );
					eff.pop();
				}
			break;
		}
	}
}

t.Mv_Skill_Alt_214EX <- 
{
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			Battle_Std.SetPosition_DamageHanteiRect({ power=50, });
		}
	}
}

t.Mv_Skill_EXS <- 	//Veil Off
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 40:
			// BMvEff.CreateObject( { pat="BloodCutin" } );
			BMvEff.Liberate_Set();
			BMvEff.AttackInfoString_Set({ word="Moves Unlocked"});
			Battle_Std.CreateObjectEX( { x = 64, y = -140, datatype=1, pat=189, flags=_Position_ToolShift } );
			local eff = Battle_Std.CreateObjectEX( { datatype=0, pat=995 } );
			if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll } );
					BMvTbl.SetPosition( { x=-32*128, y=-270*128 } );	
					BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoCamera } );
					BMvEff.SetExist( { level = _Exist_NoHantei } );
					eff.pop();
				}
			break;
		}
	}
}

t.Mv_Skill_EXS_RELEASE <- 	//Veil Off
{
	function Init_After()
	{
		BMvEff.SetCharaFlash( { color = 0xFF0000, type = 0, time = 30 } );
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 40:
			BMvEff.SetCamera_Quake( { time=15, type=2, clear=0, } );
			BMvEff.Liberate_SetMinusValue( 1500 ); // This burns VO gauge entirely
			BMvEff.PcAuraEffect_Set( { type=0, time=2000, power=3.2, color=0x88FF4444, blendmode=1, delay=120 } );
			break;
		}
	}
}
t.Mv_Throw_A <- 
{
	function HitInterrupt()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("whiffwtf",[256,"Mv_Throw_A_Hit"]); //デフォ,[code,mv]...
	}
}

t.Mv_Throw_A_Hit <- 
{
	function Init_After()
	{
		Battle_Std.MutekiThrowRelease_Init();
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			BMvEff.SetCamera_Quake( { time=15, type=0, clear=0, } ); //揺らし
		case 100: //ここから収束
			Battle_Std.MutekiThrowRelease( { FrameID=100, x=0, y=0, type="無声ダウン", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		}
	}
}

t.Mv_Standby <-
{
	function Init_After()
	{
		//BMvEff.CreateObject( { mvname="Mv_Obj_PoweUpStatus" } );
		//BMvEff.CreateObject( { mvname="Mv_Obj_UI_Manager" } );
		
		//BMvEff.CreateObject( { mvname="Mv_Obj_CloneManage" } );
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 900:
			BMvEff.CreateObject( { x=0, y=0, mvname="Mv_Obj_950ef", flags=_Position_ToolShift } );
			break;
		}
	}
}

// 登場時のインスレーター出現エフェクト
// ハイドの特殊判定の座標にくっつく
t.Mv_Obj_950ef <-
{
	function Init_After() // 
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange } );
	}
	function FrameUpdate_After() // 
	{			
		local player = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
		if( player.push() )
		{
			local oya_UpdateFrameID = Battle_Std.GetUpdateFrameID();
			
			local rc = BMvEff.GetHanteiRect( { check=[ _Hantei_Etc, 0 ], flags=0 } );
			player.pop();
			
			if( rc.sx != _Hantei_Error ) // 存在するか
			{
				local use_Xpos = (BMvTbl.GetMuki() == 1)? rc.sx : rc.ex; // 右向きならsx、左向きならex
				BMvTbl.SetPosition( { x=use_Xpos, y=rc.sy } );
			}
			if( oya_UpdateFrameID == 600 ) // 親が終了のところまで進んだ
			{
				BMvTbl.JumpFrameID( 600 ); // 消滅アニメへ
			}
		}
	}
}

//-----------------------------------------------------------------------------
// Jump
//-----------------------------------------------------------------------------

t.Mv_JumpWait_F <-
{
	function LastUpdate_After()
	{
		if( BMvTbl.CheckStickHold( (1<<7) | (1<<8) | (1<<9) ) )
		{
			BMvTbl.SetLP(0,0);
		}
		else
		{
			BMvTbl.SetLP(0,1);
		}
	}
	function FrameUpdate_After()
	{
	}
}

t.Mv_JumpWait_N <-
{
	function LastUpdate_After()
	{
		if( BMvTbl.CheckStickHold( (1<<7) | (1<<8) | (1<<9) ) )
		{
			BMvTbl.SetLP(0,0);
		}
		else
		{
			BMvTbl.SetLP(0,1);
		}
	}
	function FrameUpdate_After()
	{
	}
}

t.Mv_JumpWait_B <-
{
	function LastUpdate_After()
	{
		if( BMvTbl.CheckStickHold( (1<<7) | (1<<8) | (1<<9) ) )
		{
			BMvTbl.SetLP(0,0);
		}
		else
		{
			BMvTbl.SetLP(0,1);
		}
	}
	function FrameUpdate_After()
	{
	}
}

t.Mv_Jump_N <-
{
	function Init_After()
	{
		if( BMvTbl.GetLP(0)==1 )
		{
			BMvTbl.SetVector( { y=-2500, addy=200 flags=_Vector_Normal } );
			BSound.SE_Play( { type=_SeType_Player, num=714 } ); 
		}
	}
}

t.Mv_Jump_F <-
{
	function Init_After()
	{
		if( BMvTbl.GetLP(0)==1 )
		{
			//BMvTbl.SetVector( { x=0, y=1000, addy=0 flags=_Vector_Normal } );
			BMvTbl.SetVector( { x=1500, y=-2500, addy=200 flags=_Vector_Normal } );
			BSound.SE_Play( { type=_SeType_Player, num=714 } ); 
		}
	}
}

t.Mv_Jump_B <-
{
	function Init_After()
	{
		if( BMvTbl.GetLP(0)==1 )
		{
			BMvTbl.SetVector( { x=-1500, y=-2500, addy=200 flags=_Vector_Normal } );
			BSound.SE_Play( { type=_SeType_Player, num=714 } ); 
		}
	}
}

//This is now Air Dash B
t.Mv_Skill_J0202B <-
{
	function Init_After()
	{
		BMvTbl.AddAirCount( 1, 1 ); // 空中で何度も出せないようにする
        Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_CmdLvDZ_OK ); // 同時押しで他の行動に移れる行動
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AirAssult ); // 空中アサルト扱い
		Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag2 ); //エリアル属性を解除するMv
        Battle_Std.MoveCode.AddFlag( def_MC6_EnableCansel_SkilltoAtk );
		
		Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag2 ); //エリアル属性を解除するMv
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			break;
		case 500:
			//行動可能にして先行入力を受け付ける

				local vec = BMvTbl.GetVector(0);
				
				//print("\n 整数:"+vec.x*70/100);
				//print("\n 小数:"+vec.x*0.7);
				
				vec.x = vec.x * 70 / 100; //整数化:0.7
				if( vec.x>2000 ) vec.x = 2000;
				BMvTbl.SetVector( { x=vec.x, addx=0, addy=190, flags=_Vector_Normal } ); //減速して行動可能に
				BMvTbl.SetCommandLongDelay(2);
			break;
		}
	}
	function LastUpdate_After()
    {
		local vec = BMvTbl.GetVector(0);
				
		vec.x = vec.x * 70 / 100; //整数化:0.7
		if( vec.x>2000 ) vec.x = 2000;
		if( vec.x<2000 ) vec.x = 2000;
		BMvTbl.SetVector( { x=2000, addx=500, addy=190, flags=_Vector_Normal } ); //減速して行動可能に
		
		//でかかり数フレーム目で抜けると上昇してっちまう
		//・自分が空中
		//・addy<=0
		//だったらあがってっちゃうから保存したベクトルで上書きする
		local nowvec = BMvTbl.GetVector(0);
		local isAir = ( BMvTbl.CheckPosState(_PosState_Air)!=0 );
		
		//print("\n addy:"+nowvec.addy+" isAir:"+isAir);
		
		if( nowvec.addy <= 0 && isAir )
		{
			local vec = BMvTbl.GetVector( { flags=_Vector_Keep } ); //保存してあったのを開く
			if( vec.y <= 0 && vec.addy <= 0 ) vec.addy = 250; //無いはずだけど万が一これだとういてっちまうので救済
			BMvTbl.SetVector( { x=vec.x, y=vec.y, addx=vec.addx, addy=vec.addy, flags=_Vector_Normal } );			
		}
		//BMvTbl.SetVector( { x=0, addx=0, y=0, addy=0, flags=_Vector_Keep } ); //一応消しておく
    }
	function Finalize()
    {
        Battle_Std.MoveCode.DelFlag( def_MC_EnableCansel_SkilltoSkill );
		BMvTbl.SetNextMoveTable( "Mv_Neutral" );
    }
}

//-----------------------------------------------------------------------------
// 通常投げ
//-----------------------------------------------------------------------------

t.Mv_Throw_F_Hit <-
{
	function Init_After()
	{
		Battle_Std.SetThrowEnemyMuteki( 254 ); // 投げ中の相手に無敵時間を設定
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 900:
			BMvEff.ThrowParam( { pat=326, x=50, y=0 } );
			BMvEff.ThrowRelease( { type="前転倒", airrecover=0, flags=0 } );
			break;
		case 1000: // ここで攻撃
			Battle_Std.SetThrowEnemyMuteki( 0 ); // 投げ中の相手に無敵時間を設定
			break;
		}
	}
}

//-----------------------------------------------------------------------------
// 通常攻撃
//-----------------------------------------------------------------------------

t.Mv_Atk_StdC <-
{
	function FrameUpdate_After()
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=50, EndFrameID=60, SetPattern="StdC_End" } ); // ButtonMask, CheckFrameID, SetPattern
	}
}

t.Mv_Atk_Std6C <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK );
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_EnableCVO_OnlyCS );
	}
	function FrameUpdate_After()
	{
		Battle_Std.JumpFrameID_NotHoldButton({ mask=(1<<2), checkid=100, jumpid=101, endid=150 }); //ボタンホールドしてなかったらIDジャンプ
			
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.isLanding && BMvTbl.GetLP(0)==1 )
		{
			//BMvTbl.JumpFrameID( 201 );
		}

		if( Battle_Std.GetUpdateFrameID()==101 && BMvTbl.GetLP(0)==0 )
		{
			//Battle_Std.DrawDebugAttackInfo("zenbu_shodan");
			BMvTbl.SetLP(0,1);
			
			local vec = BMvTbl.GetVector();
			
			BMvTbl.SetVector( { y=vec.y, addy=vec.addy+160, x=vec.x, addx=vec.addx } );
		}
		
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
}

t.Mv_Atk_Std4C <-
{
	function Init_After()
	{
		Battle_Std.SetVorpalPattern( "V_4C" );
		
		// 181108 弾相殺追加
		Battle_Std.MoveCode.AddFlag( def_MC_Sousai|def_MC_Sousai_NoSubHitCount ); // 相殺が発生する
		
		// 181108 CS可能ならCVO可能に（iFF用）
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_EnableCVO_OnlyCS );
		
		BMvTbl.SetLP(0,0); // 飛び道具消したかどうか
	}
	function FrameUpdate_After() : (setSousaiBonus)
	{
		Battle_Std.JumpFrameID_NotHoldAllButton({ mask=(1<<2), checkid=[100,200], jumpid=[101,101], endid=250 }); //ボタンホールドしてなかったらIDジャンプ
		
		// 181108 弾相殺追加
		Battle_Std.CheckSousai(); // def_MC_Sousai と触れたら相殺する
		if( BMvTbl.GetLP(0)==0 && Battle_Std.MoveCode.CheckFlag( def_MC_Sousai_EnemySubSuccess ) )
		{
			BMvTbl.SetLP(0,1); // 消した
			
			setSousaiBonus( Def_Sys_FF_RecoverGRD ); // GRD増加、空振り必殺キャンセル可能に
		}	
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			// ヒットスロウをかける
			BMvEff.Slowmotion_Set( { time=10, power=6666 } );
			BMvEff.SetCamera_Quake( { type=2, time=20, } );
		}
		
		if( Battle_Std.CheckGuardTiming() )
		{
			Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
			
			local mvs = BMvTbl.GetMvStatus();
			local mvs_FrameID = mvs.FrameID;
			
			//VP時のみ削り追加
			if( mvs_FrameID == 500 || mvs_FrameID == 400 )
			{
				//IC時にさらに追加
				local dmg_val = (mvs_FrameID == 500)? 550 : 150;
				
				addKezuriDamage( dmg_val );
			}
		}
	}
}

t.Mv_Atk_CroA <-
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs|Def_HitCheckFlag_LightLegs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵と小足無敵にスカる
	}
}

t.Mv_Atk_CroB <-
{
	//function Init_After()
	//{
	//	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	//	    if( enemy.push() )
    //        {
    //           // BMvTbl.SetWallCount(0);
	//			local bs = BtlMvStd.GetBoundStatus();
	//			BMvEff.AttackInfoString_Set({word="Wall Count: " + bs.WallCount});
    //            enemy.pop();
    //        }
	//}
}

t.Mv_Atk_CroC <-
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵にスカる
	}
}

t.Mv_Atk_AirA <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	function FrameUpdate_After()
	{
		local hitnum = BMvTbl.CalcHitValue(0);  // ヒット数出現の残り取得
		if( hitnum>0 && hitnum != 2 ) // 初段以外
		{
			// 屈ガード＋空ガード可能に（空ガードは全段シールド取らないでいいように追加）
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
	}
}


t.Mv_Atk_AirB <-
{
	function Init_After()
	{
		//local bossflag = BMvCore.GetBossFlag();
		//if(BMvTbl.GetSelectColor() == 1)
		//{
		//	BMvEff.AttackInfoString_Set({word=BMvTbl.GetSelectColor() });
		//	BMvTbl.SetPattern(239);
		//}
	}
	function FrameUpdate_After()
	{
	}
}

t.Mv_Atk_AirC <-
{
	function FrameUpdate_After()
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=50, EndFrameID=60, SetPattern="AirC_End" } ); // ButtonMask, CheckFrameID, SetPattern
	}
}

//-----------------------------------------------------------------------------
// ダッシュ攻撃
//-----------------------------------------------------------------------------

t.Mv_Atk_DashStdB <-
{
	function Init_After()
	{
		//if(BMvTbl.GetSelectColor() == 1)
		//{
		//	BMvEff.AttackInfoString_Set({word=BMvTbl.GetSelectColor() });
		//	BMvTbl.SetPattern(401);
		//}
		//Battle_Std.MoveCode.AddFlag( def_MC_EnableCansel_SkilltoSkill );
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			BMvTbl.JumpFrameID(101);
			break;
		}
	}
}

t.Mv_Atk_DashStdC <- 
{
	function Init_After()
	{
		//if(BMvTbl.GetSelectColor() == 1)
		//{
		//	BMvEff.AttackInfoString_Set({word=BMvTbl.GetSelectColor() });
		//	BMvTbl.SetPattern(400);
		//}
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50: //ここから収束
			local nowvec = BMvTbl.GetVector(0); // 現在のベクトルを得る（パターン変更後だと初期化されてるかも）
			Battle_Std.InitVector(); // ベクトル初期化
			BMvTbl.SetVector( { x=nowvec.x, addx=(-nowvec.x/20), flags=_Vector_Div } ); //20Fで収束ベクトルを登録			
			break;
		case 100:  //分岐
			if( BMvTbl.CheckFurimuki() )
			{
				if (BMvTbl.JumpFrameID(256) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
				}
				BMvTbl.SetMuki(_Direction_Reverse);
			}
			break;
		}
		
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckHitTiming(200) )
		{
			if( BMvTbl.CheckFurimuki() )
			{
				if (BMvTbl.JumpFrameID(512) == -1)
				{
					_dem("【警告】飛び先のフレームIDが無い");
				}
				BMvTbl.SetMuki(_Direction_Reverse);
			}		
		}
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 100, 200 ); //削りダメージ加算　通常, VP
		}
	}
}


//-----------------------------------------------------------------------------
// 特殊技
//-----------------------------------------------------------------------------

t.Mv_Atk_Std6B <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_Atk_Cro3B <-
{
	function Init_After()
	{
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_Legs, time=255, flag=_ClearFlag_ChangeMv } ); // 足無敵にスカる
	}
}

t.Mv_Atk_Cro3C <-
{
	function FrameUpdate_After()
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=100, EndFrameID=150, SetPattern="3C_End" } ); // ButtonMask, CheckFrameID, SetPattern
		
		Battle_Std.SetHitMuteki( 1, 8, _HitCheckFlag_Head ); // Param1 & 8 の時、_HitCheckFlag_Head 頭無敵
	}
}

t.Mv_Atk_Air6C <-
{
	function FrameUpdate_After()
	{
	}
}

t.Mv_Atk_Air2C <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	function FrameUpdate_After()
	{
		Battle_Std.JumpFrameID_NotHoldButton({ mask=(1<<2), checkid=100, jumpid=101, endid=150 }); //ボタンホールドしてなかったらIDジャンプ	
	
		local hitnum = BMvTbl.CalcHitValue(0);  // ヒット数出現の残り取得
		if( hitnum>0 && hitnum != 2 ) // 初段以外
		{
			// 屈ガード＋空ガード可能に（空ガードは全段シールド取らないでいいように追加）
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
	}
}

//-----------------------------------------------------------------------------
// 214攻撃
//-----------------------------------------------------------------------------

// 181022 足元無敵追加
t.Mv_Skill_214A <- 
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );

		BMvTbl.SetForceUkemiTimeLimitFlag( { val=15, time=255, flag=_ClearFlag_ChangeMv } );
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
}
t.Mv_Skill_214B <-
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
		
		BMvTbl.SetForceUkemiTimeLimitFlag( { val=15, time=255, flag=_ClearFlag_ChangeMv } );
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
}

t.Mv_Skill_214_JAdd1 <-
{
	flags = def_TmplFlags_Add,
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
		
		BMvTbl.SetForceUkemiTimeLimitFlag( { val=19, time=255, flag=_ClearFlag_ChangeMv } );
	}
}

t.Mv_Skill_214_JAdd2 <-
{
	flags = def_TmplFlags_Add,
	function FrameUpdate_After()
	{
	}
}

t.Mv_Skill_214_JAdd3 <-
{
	flags = def_TmplFlags_Add,
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Shield_CanselNG );
	}
	function LastUpdate_After()
	{
		//Battle_Std.NoCansel_NoAttackHit();
	}
}

t.Mv_Skill_214_JAdd4 <-
{
	flags = def_TmplFlags_Add,
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Shield_CanselNG );
	}
}


t.Mv_Skill_214EX <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_214EX_JHit"]); //デフォ,[code,mv]...
	}
}


t.Mv_Skill_214EX_JHit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_SetMutekiDamage );
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			Battle_Std.SetPosition_DamageHanteiRect({ power=50, });
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.NoCansel_NoAttackHit(); //何かでキャンセルしなかった場合追撃不能にする
	}
}


//-----------------------------------------------------------------------------
// 236攻撃
//-----------------------------------------------------------------------------

local maketmpl_SkillFireBall = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		ball_st = {},
		enable_add = 0,
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.enable_add = 1;
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236A",
		pat = "FB_236B", vec = { x = 2300 }, ball=6, }
		break;
	case "B":
		mvparam.enable_add = 1;
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236B",
		pat = "FB_236B", vec = { x = 4000 }, ball=6, }
		break;
	case "C":
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236B",
		pat = "FB_236", vec = { x = 5000 }, ball=6, }
		break;
	case "EX":
		mvparam.ball_st = { x=125, y=-184, pat="FB_236EXB", mv="Mv_FireBall_236EX", vec={ x=3000 }, ball=6 };
		break;
	}

	ret_tmpl.Init_After <- function() : (mvparam)
	{
		BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 0 ); //爆破フラグリセット
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		if( mvparam.enable_add )
		{
			Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10:
			Battle_Std.CreateFireBall( mvparam.ball_st );
			break;
		}
	}	
	
	return ret_tmpl;
}

t.Mv_Skill_236A <- maketmpl_SkillFireBall( { type="A" } );
t.Mv_Skill_236B <- maketmpl_SkillFireBall( { type="B" } );
t.Mv_Skill_236EX <- maketmpl_SkillFireBall( { type="EX" } );

t.Mv_Skill_236_236A <- //爆破モーション
{
	flags = def_TmplFlags_Add,
	function Start_After()
	{
		BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 1 ); //爆破フラグセット	
		
		// 爆破も親から呼ぶようにする
		// モーションが出たら絶対に爆破が出る
		local eff = BMvEff.CreateObject( { mvname="Mv_SousaiObj_236Bakuha", start_pat="FB_236_236A" } );
		if( eff.push() )
		{
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentHitStatus } );
			BMvTbl.SetPosition( { x=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosX), y=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosY) } );
			eff.pop();
		}
	}
}

// シニスター
t.Mv_Skill_236_236B <-
{
	flags = def_TmplFlags_Add,
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			// ジャンプするところ
			// 相手が近かったら減速・遠かったら加速する
			Battle_Std.AddVector_TargetXLen( { x=450*128, xlen=170*128, power_plus=1500, power_minus=600 } );
			break;
		}
	}
}

t.Mv_Skill_236_236EX <-
{
	flags = def_TmplFlags_Add,
	function Start_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		
		BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 1 ); //爆破フラグセット	
		
		// 爆破も親から呼ぶようにする
		local eff = BMvEff.CreateObject( { start_pat="236TamaBakuhaEXPre" } );
		if( eff.push() )
		{
			BMvTbl.SetPosition( { x=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosX), y=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosY) } );
			eff.pop();
		}
	}	
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			local eff = Battle_Std.CreateFireBall( { mv="Mv_FireBall_236BakuhaEX", pat="FB_236_236EX" } );
			if( eff.push() )
			{
				BMvTbl.SetPosition( { x=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosX), y=BMvTbl.GetPP( def_PP_Hyd_236BakuhaPosY) } );
				eff.pop();
			}
			break;
		}
	}
}; //追撃モーション

t.Mv_Obj_236_BakuhaPos <-
{
	function FrameUpdate_After()
	{
		local pos = BMvTbl.GetPosition();
		BMvTbl.SetPP( def_PP_Hyd_236BakuhaPosX, pos.x );
		BMvTbl.SetPP( def_PP_Hyd_236BakuhaPosY, pos.y );
		
		//操作親のMvを見て変化
		if( BMvTbl.GetPP( def_PP_Hyd_236Bakuha ) == 1 )
		{
			BMvTbl.SetFinalize(0);
			BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 2 );//処理済み（0にすると弾がヒットストップ中で消えないことあり）
		}
		
		//操作親の飛び道具スロットが初期化されていた＝次の弾がうてるなら消える
		// 親が動けない間に消えると、
		// ヒットストップ中にコマンド成功→スロット初期化されてる→ヒットストップ終了→やっぱ出ない、があるので
		// PPに座標を入れるだけにして、爆破呼び出しは操作親からに変更
		local ball = BMvTbl.TobiParam_Func( { slot=6, type=_ValGet } )
		switch( ball )
		{
		case 0: //たまがうてるから消える
			//爆破の時も０になるよ
			BMvTbl.SetFinalize(0);
			break;
		case 1: //追加まち
			break;
		}
		
	}
}

local maketmpl_SkillFireBall2 = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		ball_st = {},
		enable_add = 0,
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.enable_add = 1;
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236A",
		pat = "FB_236B", vec = { x = 2300 }, ball=6, }
		break;
	case "B":
		mvparam.enable_add = 1;
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236B",
		pat = "FB_236B", vec = { x = 4000 }, ball=6, }
		break;
	case "C":
		mvparam.ball_st = { x=125, y=-184, mv="Mv_FireBall_236B",
		pat = "FB_236", vec = { x = 5000 }, ball=6, }
		break;
	case "EX":
		mvparam.ball_st = { x=125, y=-184, pat="FB_236EXB", mv="Mv_FireBall_236EX", vec={ x=3000 }, ball=6 };
		break;
	}

	ret_tmpl.Init_After <- function() : (mvparam)
	{
		BMvTbl.SetPP( def_PP_Hyd_236Bakuha, 0 ); //爆破フラグリセット
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
		if( mvparam.enable_add )
		{
			Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableCansel_AddCommand );
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			Battle_Std.CreateFireBall( mvparam.ball_st );
			break;
		}
	}	
	
	return ret_tmpl;
}

t.Mv_Skill_236_214A <- maketmpl_SkillFireBall2( { type="A" } );
t.Mv_Skill_236_214B <- maketmpl_SkillFireBall2( { type="B" } );

t.Mv_FireBall_236A <-
{
	function Init_After()
	{
		//弾にくっついていく爆破予告
		local eff = BMvEff.CreateObject( { x=0, y=0, mvname="Mv_Obj_236_BakuhaPos", flags=_Position_ToolShift } );
		if( eff.push() )
		{
			BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
			BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoRender|_ObjFlags_NoGround } );
			BMvEff.SetExist( { level = _Exist_NoHantei } );
			BMvTbl.SetPosition( { y=0 } );
			
			eff.pop();
		}
		Battle_Std.MoveCodeEx.AddFlag( 6, def_MC6_EnableAtemiCatchedHitStopAddObject ); // 当身取られたときにヒットストップあり
	}
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if ( mvs.MvCount%1 == 0 && mvs.CallCount == 0 )
		{
			local pos = BMvEff.Random_PointRad( { radx=30, rady=30 } );
			Battle_Std.CreateObjectEX( { x=pos.x, y=pos.y, pat="340Dust", FrameID=[1,2,3], flags=_Position_ToolShift } );
		}
		//操作親のPPを見て変化
		if( BMvTbl.GetPP( def_PP_Hyd_236Bakuha ) > 0 )
		{
			BMvTbl.SetFinalize(0);
		}
	}
}

t.Mv_FireBall_236A_Hit <- //飛び道具ヒット部分
{
	function Init_After() // 初回処理
	{
		BMvTbl.SetPattern("FB_236Hit");
	}
}

t.Mv_FireBall_236A_Sousai <- //飛び道具ヒット部分
{
	function Init_After() // 初回処理
	{
		BMvTbl.SetPattern("FB_236Hit");
	}
}

t.Mv_FireBall_236A_Blocked <- //飛び道具ヒット部分
{
	function Init_After() // 初回処理
	{
		BMvTbl.SetPattern("FB_236Hit");
	}
}

t.Mv_FireBall_236B <- t.Mv_FireBall_236A;
t.Mv_FireBall_236B_Hit <- t.Mv_FireBall_236A_Hit;
t.Mv_FireBall_236B_Sousai <- t.Mv_FireBall_236A_Sousai;
t.Mv_FireBall_236B_Blocked <- t.Mv_FireBall_236A_Blocked;

t.Mv_SousaiObj_236Bakuha <-
{
	function Init()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
		Battle_Std.MoveCode.AddFlag( def_MC_Sousai ); // 相殺が発生する
		
		BMvTbl.SetHitCheckFlag( { type=1, val=_HitCheckFlag_FireBall, time=255, flag=_ClearFlag_ChangeMv } ); // 弾無敵にスカる
		
		// 相手がやられで、ある程度近くにいたら出現位置ずらす
		// 見た目の都合で前方のみのサーチ
		if( Battle_Std.CheckEnemyisDamage() )
		{
			BtlOb.SetPos_MoveForwardFartherX_Enemy( { farther_x=50*128, addlimit_x=50*128, } );//これより遠いと近づく, 加算限界X
		}
	}
	function FrameUpdate()
	{
		Battle_Std.CheckSousai(); // def_MC_Sousai と触れたら相殺する
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_FireBall_236BakuhaEX <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
}

t.Mv_FireBall_236BakuhaEX_Sousai <-
{
	function Init_After()
	{
		BMvTbl.JumpFrameID(900);
	}
}

t.Mv_FireBall_236BakuhaEX_Blocked <-
{
	function Init_After()
	{
		BMvTbl.JumpFrameID(900);
	}
}



t.Mv_FireBall_236EX <-
{
	function Init_After()
	{
		BMvTbl.TobiParam_Func( { slot=7, val=1, type=_ValAdd } ); //EXのときは７も
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );		
	}
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus(); // ステータス取得
		if ( mvs.MvCount%1 == 0 && mvs.CallCount == 0 )
		{
			local pos = BMvEff.Random_PointRad( { radx=30, rady=30 } );
			Battle_Std.CreateObjectEX( { x=pos.x, y=pos.y, pat="340EXDust", FrameID=[1,2,3], flags=_Position_ToolShift } );
		}
	}	
	function LastUpdate_After()
	{
		BMvTbl.TobiParam_Func( { slot=7, type=_ValClear  } ); //EXのときは７も		
	}
}

t.Mv_FireBall_236EX_Sousai <-
{
	function Init_After()
	{
		BMvTbl.JumpFrameID( 512 );
	}
};

t.Mv_FireBall_236EX_Blocked <-
{
	function Init_After()
	{
		BMvTbl.JumpFrameID( 512 );
	}
};

//-----------------------------------------------------------------------------
// 421攻撃
//-----------------------------------------------------------------------------

t.Mv_Skill_421A <-
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			Battle_Std.CreateFireBall({ x=-120, y=-350, mv="Mv_FireBall_421A", pat="ChenFB", ball=5, });	
			//BMvEff.Chara_SetMessage( 640, 640-20, "What if Fatih wall splatted me?", 120, 0 );
			break;
		}
	}
}

t.Mv_FireBall_421A <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
			case 100:
				BMvTbl.SetVector( { x=3000, addx=80, y=-750 flags=_Vector_Normal } );
				break;
		}
	}
}

t.Mv_Skill_421B <-
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			Battle_Std.CreateFireBall({ x=-120, y=-350, mv="Mv_FireBall_421B", pat="RanFB", ball=4, });	
			//BMvEff.Chara_SetMessage( 640, 640-20, "What if Fatih wall splatted me?", 120, 0 );
			break;
		}
	}
}

t.Mv_FireBall_421B <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
			case 100:
				BMvTbl.SetVector( { x=3000, addx=80, y=750 flags=_Vector_Normal } );
				break;
		}
	}
}

//-----------------------------------------------------------------------------
// 0202攻撃
//-----------------------------------------------------------------------------

t.Mv_FireBall_0202A <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern } );
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 30, 60 ); //削りダメージ加算　通常, VP
		}
	}
}

t.Mv_FireBall_0202A_Hit <- {};
t.Mv_FireBall_0202A_Sousai <- {
	function Init_After()
	{
		BMvTbl.SetFinalize();
	}
};
t.Mv_FireBall_0202A_Blocked <- {
	function Init_After()
	{
		BMvTbl.SetFinalize();
	}
};

t.Mv_FireBall_0202B <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern } );
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 50, 100 ); //削りダメージ加算　通常, VP
		}
	}
}

t.Mv_FireBall_0202B_Hit <- t.Mv_FireBall_0202A_Hit
t.Mv_FireBall_0202B_Sousai <- t.Mv_FireBall_0202A_Sousai;
t.Mv_FireBall_0202B_Blocked <- t.Mv_FireBall_0202A_Sousai;

local maketmpl_SkillThrustGroundWave = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		ball_xpos = 450,
		ball_mv = "Mv_FireBall_0202A",
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.ball_xpos = 450;
		mvparam.ball_mv = "Mv_FireBall_0202A";
		break;
	case "B":
		mvparam.ball_xpos = 700;
		mvparam.ball_mv = "Mv_FireBall_0202B";
		break;
	case "C":
		mvparam.ball_xpos = 850;
		mvparam.ball_mv = "Mv_FireBall_0202B";
		break;
	}
	
	ret_tmpl.Init_After <- function()
	{
		BMvTbl.SetLP(0,0); // 初段がヒットしたかどうか
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			// 軸移動
			Battle_Std.AddToolShift_NoSurinuke( 100, (1<<1) );
			break;
		case 110:
			local create_posx = mvparam.ball_xpos*128;
			
			local pos = BMvTbl.GetPosition(0);
			local muki = BMvTbl.GetMuki();
			local set_posx = pos.x + ( create_posx*muki );
			
			if( muki == 1 )
			{
				if( set_posx >= def_POS_GamenHajiX )
				{
					create_posx -=(set_posx-def_POS_GamenHajiX)
				}
			}
			else
			{
				if( set_posx <= -def_POS_GamenHajiX )
				{
					create_posx +=(def_POS_GamenHajiX+set_posx)
				}
			}
			if( BMvTbl.GetLP(0)==1 )
			{
				local edis = Battle_Std.GetEnemyDistance();
				if( create_posx > edis )
				{
					//生成予定先座標
					create_posx -= (create_posx-edis)*50/100;//少し吸い寄せ
				}
			}
			
			//生成後に座標を変更すると、判定ツールでよんでいるエフェクトの座標が追尾してくれないので
			//生成予定の座標を変更するように変更
			local eff = Battle_Std.CreateFireBall( { x=create_posx/128, y=0, pat="FB_0202", mv=mvparam.ball_mv } );		
			if( eff.push() )
			{
				BMvEff.ObjType_Set( { type=_ObjType_FireBall } ); //飛び道具
				Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定		
				
				eff.pop();
			}
			break;
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			BMvTbl.SetLP(0,1); // 初段がヒット
		}
	}
	
	return ret_tmpl;
}

t.Mv_Skill_0202A <- maketmpl_SkillThrustGroundWave( { type="A" } );
t.Mv_Skill_0202B <- maketmpl_SkillThrustGroundWave( { type="B" } );

t.Mv_Skill_0202EX <-
{
	//function Init_After()
	//{
	//	local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
	//	if( enemy.push() )
	//	{
	//		BMvTbl.SetWallCount(0);
	//		local bs = BtlMvStd.GetBoundStatus();
	//		BMvEff.AttackInfoString_Set({word="Wall Count: " + bs.WallCount});
	//	    enemy.pop();
	//	}
	//}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			// 軸移動
			Battle_Std.AddToolShift_NoSurinuke( 100, (1<<1) );
			break;
		case 100:
			BMvEff.CreateObject( { x=150, y=0, mvname="Mv_Obj_0202EXMover", flags=_Position_ToolShift } );
			break;
		}
	}
}

t.Mv_Obj_0202EXMover <-
{
	function Init_After()
	{
		BMvTbl.SetLP(1,0); // 子がヒットしたかどうかの受け皿
	}
	function FrameUpdate_After()
	{
		if( Battle_Std.CheckPlayerisDamage() )
		{
			BMvTbl.SetFinalize();
			return;
		}
		
		// _dp("\n BMvTbl.GetLP(1):"+BMvTbl.GetLP(1) );
		local pat = 0;
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10: //小
			pat = "FB_0202EX1";
			break;
		case 20: //中
			pat = "FB_0202EX2";
			break;
		case 30: //大
			pat = "FB_0202EX3";
			break;
		}
		if( pat!=0 )
		{
			local eff = Battle_Std.CreateFireBall( { x=0, y=0, pat=pat, mv="Mv_FireBall_0202EX" } );
		}
		
		if( Battle_Std.CheckFrontStageDistance( -150 ) )
		{
			local vec = BMvTbl.GetVector( 0 );
			BMvTbl.SetMuki( _Direction_Reverse );
			BMvTbl.SetVector( { x=vec.x, flags=_Vector_Normal } );
		}
	}
}

t.Mv_FireBall_0202EX <-
{
	function Init_After()
	{
		// LPの処理はなくなったが一応このフラグは残しておく
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull } ); // ヒット時親LPに値を入れるので親の引継ぎなし
	}
	function HitInterrupt_After() : (addKezuriDamage)
	{
		if( Battle_Std.CheckGuardTiming() )
		{
			addKezuriDamage( 10, 20 ); //削りダメージ加算　通常, VP
		}
	}
}

t.Mv_FireBall_0202EX_Hit <- {};
t.Mv_FireBall_0202EX_Sousai <- {};
t.Mv_FireBall_0202EX_Blocked <- {
	function Init_After()
	{
		BMvTbl.SetFinalize();
	}
};



//-----------------------------------------------------------------------------
// J236攻撃
//-----------------------------------------------------------------------------

local maketmpl_SkillAirFireBall = function( param={} )
{
	local ret_tmpl = {};
	
	local mvparam =
	{
		ball_st = {},
		aircount_slot = -1,
		forcefunction = 0,
	}
	
	switch( param.type )
	{
	case "A":
		mvparam.ball_st = { x=0, y=50, mv="Mv_FireBall_J236A", pat = "FB_J236", };
		mvparam.aircount_slot = 0;
		break;
	case "B":
		mvparam.ball_st = { x=0, y=50, mv="Mv_FireBall_J236B", pat = "FB_J236", };
		mvparam.aircount_slot = 1;
		break;
	case "EX":
		mvparam.ball_st = { x=0, y=50, mv="Mv_FireBall_J236EX", pat = "FB_J236EX", };
		mvparam.aircount_slot = 2;
		break;
	case "BC":
		mvparam.ball_st = { x=50, y=50, mv="Mv_FireBall_J236A", pat = "FB_J236", };
		mvparam.aircount_slot = 0;
		mvparam.forcefunction = 1;
		break;
	}
	
	ret_tmpl.Start_After <- function() : (mvparam)
	{
		if( mvparam.aircount_slot != -1 )
		{
			BMvTbl.AddAirCount( mvparam.aircount_slot, 1 );
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvparam)
	{	
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 10:
			Battle_Std.CreateFireBall( mvparam.ball_st );
			local player = BMvCore.GetPlayerCharaData();
			if(player.push() && mvparam.forcefunction)
			{
				local p_stick_forward = BMvTbl.CheckStickHold((1<<6));
				player.pop();
				if(p_stick_forward)
				{
					BMvTbl.SetVector( { x=1250, y=-3000, addy=200 flags=_Vector_Normal } );
				}
				else
				{
					BMvTbl.SetVector( { x=-750, y=-3000, addy=200 flags=_Vector_Normal } );
				}
			}
			break;
		}
	}	
	
	return ret_tmpl;
}

//t.Mv_Skill_J236A <- maketmpl_SkillAirFireBall( { type="A" } );
//t.Mv_Skill_J236B <- maketmpl_SkillAirFireBall( { type="B" } );
//t.Mv_Skill_J236EX <- maketmpl_SkillAirFireBall( { type="EX" } );
t.Mv_Atk_AirBandC <- maketmpl_SkillAirFireBall( { type="BC" } );
t.Mv_Skill_J41236EX <- maketmpl_SkillAirFireBall( { type="EX" } );

t.Mv_Skill_J236A <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_After()
	{
		if( Battle_Std.GetUpdateFrameID()==100 && BMvTbl.GetLP(0)==0 )
		{
			//Battle_Std.DrawBladeEffect( { x=0, y=0, pat=0x58, } );
			local pat = 0x58; //120
			
			//local eff = BMvEff.CreateObject( { x=153, y=-70, start_pat=120, flags=_Position_ToolShift } );
			{
				local eff = BMvEff.CreateObject( { x=-200, y=190, start_pat=pat, flags=_Position_ToolShift } );
				if(eff.push())
				{
					BMvTbl.SetAngle( { angle_float=0.020 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_FromParentStop|_ObjFlags_NoGround } );
					//_ObjProcFlags_EraseChangeParentMv
					//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
					
					BMvTbl.SetScale( { x=150*100, y=250*100 } );
					
					eff.pop();
				}
			}
			
			{
				local eff = BMvEff.CreateObject( { x=140, y=-100, start_pat=155, flags=_Position_ToolShift } );
				if(eff.push())
				{
					BMvTbl.SetAngle( { angle_float=0.5 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
					//_ObjProcFlags_EraseChangeParentMv
					//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
					
					//BMvTbl.SetScale( { x=1*100, y=1*100 } );
					
					eff.pop();
				}
			}
			

			
			//Battle_Std.DrawDebugAttackInfo("heightdif "+BMvTbl.GetLP(0));
			
			BMvTbl.SetLP(0,1);
		}
	}
}

t.Mv_Skill_J236B_Hit <-
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Shield_CanselNG );
		Battle_Std.MoveCode.AddFlag( def_MC_EnableCansel_SkilltoSkill );
		
		BMvTbl.SetCommandLongDelay(2);
		
	}
}

t.Mv_Skill_J236B <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);
		BMvTbl.SetLP(1,0);
		
		Battle_Std.MoveCode.AddFlag( def_MC_EnableCansel_SkilltoSkill );
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_Shield_CanselNG );
	}
	function FrameUpdate_After()
	{
		if( Battle_Std.GetUpdateFrameID()==100 && BMvTbl.GetLP(0)==0 )
		{
			//Battle_Std.DrawBladeEffect( { x=0, y=0, pat=0x58, } );
			local pat = 0x58; //120
			
			//local eff = BMvEff.CreateObject( { x=153, y=-70, start_pat=120, flags=_Position_ToolShift } );
			{
				local eff = BMvEff.CreateObject( { x=-200, y=190, start_pat=pat, flags=_Position_ToolShift } );
				if(eff.push())
				{
					BMvTbl.SetAngle( { angle_float=0.020 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_FromParentStop|_ObjFlags_NoGround } );
					//_ObjProcFlags_EraseChangeParentMv
					//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
					
					BMvTbl.SetScale( { x=150*100, y=250*100 } );
					
					eff.pop();
				}
			}
			
			{
				local eff = BMvEff.CreateObject( { x=140, y=-100, start_pat=155, flags=_Position_ToolShift } );
				if(eff.push())
				{
					BMvTbl.SetAngle( { angle_float=0.5 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
					//_ObjProcFlags_EraseChangeParentMv
					//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
					
					//BMvTbl.SetScale( { x=1*100, y=1*100 } );
					
					eff.pop();
				}
			}
			
			//Battle_Std.DrawDebugAttackInfo("heightdif "+BMvTbl.GetLP(0));
			
			BMvTbl.SetLP(0,1);
		}
	}
	function HitInterrupt_After()
	{
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			local isShield = ( bs.isBound==2 && BMvEff.GuardSP_Success() );
			enemy.pop();
			
			if( isShield )
			{
				// _dp("\n シールド中...:"+isShield );
				BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_ShieldStand|_GuardFlag_ShieldAir|_GuardFlag_ShieldCrouch, time=2, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } )
			}
		
		
			local mvs = BMvTbl.GetMvStatus();
			if( mvs.FrameID==100 && BMvTbl.GetLP(1)==1 && !isShield ) BMvTbl.SetFinalize( 256 );
		}
		
		if( Battle_Std.CheckHitTiming() )
		{
			BMvTbl.SetLP(1,1);
		}		
	}
	function Finalize_After()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Skill_J236B_Hit"]); //デフォ,[code,mv]...				
	}
}

t.Mv_Skill_J236EX <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_After()
	{
		if( Battle_Std.GetUpdateFrameID()==100 && BMvTbl.GetLP(0)==0 )
		{
			//Battle_Std.DrawBladeEffect( { x=0, y=0, pat=0x58, } );
			local pat = 0x58; //120
			
			//local eff = BMvEff.CreateObject( { x=153, y=-70, start_pat=120, flags=_Position_ToolShift } );
			{
				local eff = BMvEff.CreateObject( { x=-200, y=190, start_pat=pat, flags=_Position_ToolShift } );
				if(eff.push())
				{
					BMvTbl.SetAngle( { angle_float=0.020 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_FromParentStop|_ObjFlags_NoGround } );
					//_ObjProcFlags_EraseChangeParentMv
					//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
					
					BMvTbl.SetScale( { x=150*100, y=250*100 } );
					
					eff.pop();
				}
			}
			
			{
				local eff = BMvEff.CreateObject( { x=140, y=-100, start_pat=155, flags=_Position_ToolShift } );
				if(eff.push())
				{
					BMvTbl.SetAngle( { angle_float=0.5 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
					//_ObjProcFlags_EraseChangeParentMv
					//BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseParentNull|_ObjProcFlags_EraseChangeParentMv } );
					
					//BMvTbl.SetScale( { x=1*100, y=1*100 } );
					
					eff.pop();
				}
			}
			

			
			//Battle_Std.DrawDebugAttackInfo("heightdif "+BMvTbl.GetLP(0));
			
			BMvTbl.SetLP(0,1);
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming_FrameID( 20 ) )
		{
			BMvTbl.SetFinalize( 256 );
			
			//相手との距離が近かったらベクトル収束させる
			local kyori = Battle_Std.GetEnemyDistance()/128;
			// _dp("\n kyori:"+kyori );
			if( kyori <= 200 && kyori >= 0 )
			{
				// 120〜320 : 普通にヒット　かなり遅くする
				// 320〜    : 牽制とかにヒット　500ぐらいまではあるな
				
				// 200以内収束させる感じで
				local conv_par = (kyori / 2) * 85 / 100;
				if( conv_par < 30 ) conv_par = 10;
				if( conv_par > 100 ) conv_par = 100;

				local vec = BMvTbl.GetVector();

				// _dp("\n conv_par:"+conv_par+" x:"+vec.x );
				vec.x = vec.x * conv_par / 100;
				// _dp(" -> "+vec.x );
				
				BMvTbl.SetVector( { x=vec.x, addx=vec.addx, flags=_Vector_Normal } );
				
			}
		}
	}
	function Finalize_After()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Skill_J236EX_Hit"]); //デフォ,[code,mv]...				
	}
}

t.Mv_Skill_J236EX_Hit <-
{
	flags = def_TmplFlags_ChangeStatusOnly //状態の移行のみ行う
	function Init_After()
	{
		Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_CSAntenGaesiSkill ); // 前のMVからフラグの引き継ぐ
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			BMvTbl.JumpFrameID(200);
			break;
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.CSAntenGaesi_DamageHosei(); // CSからの暗転返しで出したら補正をかける
		Battle_Std.NoCansel_NoAttackHit(); //何かでキャンセルしなかった場合追撃不能にする
	}	
}

t.Mv_FireBall_J236A <-
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
}


t.Mv_FireBall_J236A_Sousai <- //飛び道具ヒット部分
{
	function Init_After() // 初回処理
	{
		BMvTbl.JumpFrameID( 256 )
	}
}

t.Mv_FireBall_J236A_Blocked <- 
{
	function Init_After() // 初回処理
	{
		BMvTbl.JumpFrameID( 256 )
	}
}

t.Mv_FireBall_J236B <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236B_Sousai <- t.Mv_FireBall_J236A_Sousai;
t.Mv_FireBall_J236B_Blocked <- t.Mv_FireBall_J236A_Sousai;

t.Mv_FireBall_AirBandC <- t.Mv_FireBall_J236A;
t.Mv_FireBall_AirBandC_Sousai <- t.Mv_FireBall_J236A_Sousai;
t.Mv_FireBall_AirBandC_Blocked <- t.Mv_FireBall_J236A_Sousai;


// ナナセ623の引き寄せ処理
local moveenemy = function( _frame )
{
	local enemy = BMvEff.CheckHantei( { src=[ _Hantei_Etc, 4, 1 ], dst=[ _Hantei_Kurai, 0, -1 ], flags=_HC_EnemyPc } );
	if( enemy.isdone() )
	{
		local posst = BMvEff.GetPointStatus( { target=enemy } );
		local kyori = posst.pos_x; // 向きを計算しない
		local move_pow = -kyori/_frame;
		
		if( enemy.push() )
		{
			local bs = BtlMvStd.GetBoundStatus();
			if( bs.isDone )
			{
				BMvTbl.SetPosition( { x=move_pow, flags=_Position_Add } );
			}
			
			enemy.pop();
		}
	}	
}

t.Mv_FireBall_J236EX <- 
{
	function Init_After()
	{
		// 各種補正は最初の１ヒットのみ
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } );
	}
	function FrameUpdate_After() : (moveenemy)
	{
		moveenemy(10);
	}
}

t.Mv_FireBall_J236EX_Sousai <- t.Mv_FireBall_J236A_Sousai;
t.Mv_FireBall_J236EX_Blocked <- t.Mv_FireBall_J236A_Sousai;

//-----------------------------------------------------------------------------
// J214攻撃
//-----------------------------------------------------------------------------

local GetControlTmplTable = function( tbl={} )
{
	//tbl.plus_x　 ：　Ｘ慣性加算値
	//tbl.plus_y　 ：　Ｙ慣性加算値
	//tbl.CheckMv　：　親がこのMvじゃなかったら終了　※かならず必要
	//tbl.EndFrameID ：　親がこのFrameIDになったら終了
	
	local tmpl = {};
	
	tmpl.Init_After <- function()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_NoRender|_ObjFlags_ParentMove|_ObjFlags_EraseParentDamage|_ObjFlags_EraseParentPatChange } );
		
		BMvEff.SetExist( { level = _Exist_NoHantei } );
		
		BMvEff.ObjProcFlags_Set( { flags=_ObjProcFlags_EraseChangeParentMv } );
		
		//LPを使って慣性を管理
		//LP 0 Xベクトル
		//LP 1 Yベクトル
		BMvTbl.SetLP(0,0); // Xベクトル記憶用 初期化
		BMvTbl.SetLP(1,0); // Yベクトル記憶用 初期化
	}
	
	local plus_x = ("plus_x" in tbl)? tbl.plus_x : 0;
	local plus_y = ("plus_y" in tbl)? tbl.plus_y : 0;
	local endid = ("EndFrameID" in tbl)? tbl.EndFrameID : 0;
	local endid2 = ("EndFrameID2" in tbl)? tbl.EndFrameID2 : 0;
	local lastAdd_x = ("lastAdd_x" in tbl)? tbl.lastAdd_x : 0;
	local lastAdd_y = ("lastAdd_y" in tbl)? tbl.lastAdd_y : 0;
	local max_x = ("max_x" in tbl)? tbl.max_x : 0;
	local max_y = ("max_y" in tbl)? tbl.max_y : 0;
	local min_x = ("min_x" in tbl)? tbl.min_x : 0;
	local min_y = ("min_y" in tbl)? tbl.min_x : 0;
	local brake_x = ("brake_x" in tbl)? tbl.brake_x : 80;
	local brake_y = ("brake_y" in tbl)? tbl.brake_y : 80;
	
	tmpl.FrameUpdate_After <- function() : (plus_x, plus_y, endid, endid2, lastAdd_x, lastAdd_y, max_x, max_y, min_x, min_y, brake_x, brake_y)
	{
		//親のMvが変わるか、とどめが出たら終わる
		local pls = Battle_Std.GetPlayerMvStatus();
		if( (endid!=0 && pls.FrameID==endid) || (endid2!=0 && pls.FrameID==endid2) )
		{
			BMvTbl.SetFinalize(0);
			return; //この先には進ませない
		}
	
		local x = BMvTbl.GetLP(0);
		local y = BMvTbl.GetLP(1);
		//操作親に対してベクトルを与える
		local player = BMvCore.GetPlayerCharaData(); // プレイヤー情報取得
		if( player.push() )
		{
			//CheckCommandStringだとコマンドなので地上コマンドは相手への向き依存になるから気をつけよう
		
			if( BMvTbl.CheckStickHold( (1<<4) | (1<<7) | (1<<1) ) ) x -= plus_x;
			if( BMvTbl.CheckStickHold( (1<<6) | (1<<9) | (1<<3) ) ) x += plus_x;
			if( BMvTbl.CheckStickHold( (1<<8) | (1<<7) | (1<<9) ) ) y -= plus_y;
			if( BMvTbl.CheckStickHold( (1<<2) | (1<<1) | (1<<3) ) ) y += plus_y;	
		
			//適当に減速する
			x = x * brake_x/100;
			y = y * brake_y/100;
			
			if( x >  1500 ) x =  1500;
			if( x < -1300 ) x = -1300;
			if( y >  1500 ) y =  1500;
			if( y < -1300 ) y = -1300;
			
			//座標が高すぎたら補正をかけるとか
			local pos = BMvTbl.GetPosition(0); //操作親の座標
			local use_lastAdd_y = lastAdd_y;
			if( pos.y <= -70000 && y < 0 )
			{
				y = 0;
				use_lastAdd_y = 0;
			}
			if( pos.y >= -5000 && y > 0 )
			{
				y = 0;
				use_lastAdd_y = 0;
			}
			
			local nowvec = BMvTbl.GetVector(0);
			BMvTbl.SetVector( { x=x+lastAdd_x, y=nowvec.y, flags=_Vector_Normal } );
			
			player.pop();
		}
		
		
		//保存
		BMvTbl.SetLP(0,x);
		BMvTbl.SetLP(1,y);
		
		//print(format( "\n X:%d Y:%d",x,y ));		
	
	
	}
	
	//作ったtmplを返す
	return tmpl;
}

t.Mv_Obj_J214_Control <-  GetControlTmplTable( {
	plus_x=320,		//レバーによる移動値
	max_x=2000, min_x=-2000,			//限界値Ｘ		//限界値Ｙ
	lastAdd_x=256,	//強制的に加算される移動値
	brake_x=80,		//毎フレームの減速係数
	EndFrameID=48 //終了チェック
});

t.Mv_Skill_J214A <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);
		
		BMvEff.CreateObject( { mvname="Mv_Obj_J214_Control" } );
	}
	function FrameUpdate_After()
	{
		if( Battle_Std.GetUpdateFrameID()==10 && BMvTbl.GetLP(0)==0 )
		{
			//Battle_Std.DrawBladeEffect( { x=0, y=0, pat=0x58, } );
			//local pat = 0x58; //120
			
			//local eff = BMvEff.CreateObject( { x=153, y=-70, start_pat=120, flags=_Position_ToolShift } );
			{
				local eff = BMvEff.CreateObject( { start_pat="J214LightningEff", flags=_Position_ToolShift } );
				if(eff.push())
				{
					//BMvTbl.SetAngle( { angle_float=0.020 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
					
					//BMvTbl.SetScale( { x=150*100, y=250*100 } );
					
					BMvTbl.SetPosition( { y=0 } );
					BSound.SE_Play( { type=_SeType_Player, num=16 } );
					
					eff.pop();
				}
			}
			
			BMvTbl.SetLP(0,1);
			
			BMvTbl.SetPosition( { y=0 } );
		}
		if( Battle_Std.GetUpdateFrameID()==10 ) BMvEff.SetCharaFlash( { color = 0xffffff, type = 0, intime = 30, time = 20 } );
		
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming_FrameID(15) )
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvTbl.SetPosition( { y=0 } );
				enemy.pop();
			}
		}
	}
}

t.Mv_Skill_J214B <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_After()
	{
		if( Battle_Std.GetUpdateFrameID()==10 && BMvTbl.GetLP(0)==0 )
		{
			//Battle_Std.DrawBladeEffect( { x=0, y=0, pat=0x58, } );
			//local pat = 0x58; //120
			
			//local eff = BMvEff.CreateObject( { x=153, y=-70, start_pat=120, flags=_Position_ToolShift } );
			{
				local eff = BMvEff.CreateObject( { start_pat="J214LightningEff", flags=_Position_ToolShift } );
				if(eff.push())
				{
					//BMvTbl.SetAngle( { angle_float=0.020 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
					
					//BMvTbl.SetScale( { x=150*100, y=250*100 } );
					
					BMvTbl.SetPosition( { y=0 } );
					BSound.SE_Play( { type=_SeType_Player, num=16 } );
					
					eff.pop();
				}
			}
			
			BMvTbl.SetLP(0,1);
			
			BMvTbl.SetPosition( { y=0 } );
		}
		if( Battle_Std.GetUpdateFrameID()==10 ) BMvEff.SetCharaFlash( { color = 0xffffff, type = 0, intime = 30, time = 20 } );
		
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming_FrameID(15) )
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvTbl.SetPosition( { y=0 } );
				enemy.pop();
			}
		}
	}
}

//t.Mv_Skill_J214EX <-
//{
//	function HitInterrupt_After()
//	{
//		if( Battle_Std.CheckDamageTiming() )
//		{
//			Battle_Std.SetPosition_DamageHanteiRect({ power=50, });
//		}
//		
//		local hs = BMvTbl.GetMvHitStatus();
//		if( hs.Type & _HitType_Damage && hs.isCatchFlag == 0 )
//		{
//			BMvTbl.SetFinalize(256); //ヒットMvに状態移行
//		}
//	}
//	function Finalize()
//	{
//		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_J214EX_Hit"]); //デフォ,[code,mv]...
//	}
//}
//
//
//t.Mv_Skill_J214EX_Hit <-
//{
//	flags = def_TmplFlags_NoAddComboRate|def_TmplFlags_ChangeStatusOnly // コンボレートを加算しない, 状態の移行のみ行う
//	function HitInterrupt_After()
//	{
//		if( Battle_Std.CheckDamageTiming() )
//		{
//			Battle_Std.SetPosition_DamageHanteiRect({ power=50, });
//		}
//	}
//	function LastUpdate_After()
//	{
//		Battle_Std.NoCansel_NoAttackHit(); //何かでキャンセルしなかった場合追撃不能にする
//	}
//}

t.Mv_Skill_J214EX <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_J214EX_Hit"]); //デフォ,[code,mv]...
	}
}


t.Mv_Skill_J214EX_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_SetMutekiDamage );
		BMvTbl.SetLP(0,0);
	}
	function FrameUpdate_After()
	{
		if( Battle_Std.GetUpdateFrameID()==15 && BMvTbl.GetLP(0)==0 )
		{
			//Battle_Std.DrawBladeEffect( { x=0, y=0, pat=0x58, } );
			//local pat = 0x58; //120
			
			//local eff = BMvEff.CreateObject( { x=153, y=-70, start_pat=120, flags=_Position_ToolShift } );
			{
				local eff = BMvEff.CreateObject( { start_pat="J214LightningEff", flags=_Position_ToolShift } );
				if(eff.push())
				{
					//BMvTbl.SetAngle( { angle_float=0.020 } );
					BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround } );
					
					//BMvTbl.SetScale( { x=150*100, y=250*100 } );
					
					BMvTbl.SetPosition( { y=0 } );
					BSound.SE_Play( { type=_SeType_Player, num=16 } );
					
					eff.pop();
				}
			}
			
			BMvTbl.SetLP(0,1);
			
			BMvTbl.SetPosition( { y=0 } );
		}
		if( Battle_Std.GetUpdateFrameID()==15 ) BMvEff.SetCharaFlash( { color = 0xffffff, type = 0, intime = 30, time = 20 } );
		
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			Battle_Std.SetPosition_DamageHanteiRect({ power=50, });
		}
		if( Battle_Std.CheckDamageTiming_FrameID(20) )
		{
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvTbl.SetPosition( { y=0 } );
				enemy.pop();
			}
		}
	}
}

//-----------------------------------------------------------------------------
// 623攻撃
//-----------------------------------------------------------------------------

t.Mv_Skill_623A <-
{
	function Init_After()
	{
		local gauge_status = BMvEff.Liberate_Get();
		if( BMvEff.Liberate_GetType() == _LiberateType_Combo ) BMvEff.AttackInfoString_Set({word="Whatda 1"});
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki2_Param1( { [8]=_HitCheckFlag_Head, [64]=Def_HitCheckFlag_AirDive } );
		
		Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK ); // ツールでCS可なら空振りCS可能
	}
};
t.Mv_Skill_623B <-
{
	function Init_After()
	{
		// 181108 カス当たりしづらいように吸い込み追加
		BMvTbl.SetLP(0,0);
	}
	function HitInterrupt_After()
	{
		// １回目のヒットだけ引き寄せる処理
		if( BMvTbl.GetLP(0)==0 )
		{
			if( Battle_Std.CheckDamageTiming() )
			{
				Battle_Std.SetPosition_DamageHanteiRect({ power=50, distance=500*128, flags=(1<<1)|(1<<2) }); // 高さ無効、地上でも引き寄せ
				BMvTbl.SetLP(0,1);
			}
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.CSAntenGaesi_DamageHosei(); // CSからの暗転返しで出したら補正をかける
		Battle_Std.NoCansel_NoAttackHit(); //何かでキャンセルしなかった場合追撃不能にする
	}
};
t.Mv_Skill_623EX <- {
	function Init_After()
	{
		// 181108 カス当たりしづらいように吸い込み追加
		BMvTbl.SetLP(0,0);
	}
	function HitInterrupt_After()
	{
		// １回目のヒットだけ引き寄せる処理
		if( BMvTbl.GetLP(0)==0 )
		{
			if( Battle_Std.CheckDamageTiming() )
			{
				Battle_Std.SetPosition_DamageHanteiRect({ power=50, distance=500*128, flags=(1<<1)|(1<<2) }); // 高さ無効、地上でも引き寄せ
				
				BMvTbl.SetLP(0,1);
			}
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.CSAntenGaesi_DamageHosei(); // CSからの暗転返しで出したら補正をかける
	}
};

//-----------------------------------------------------------------------------
// 41236EX攻撃
//-----------------------------------------------------------------------------

t.Mv_Skill_41236EX <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);//初段引き寄せ
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 30:
			BMvEff.CreateObject({ x=153*128, start_pat="41236EX_Tama", mvname="Mv_Obj_41236EX_Tama",});
			break;
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			local mvs = BMvTbl.GetMvStatus();
			local frame_id = mvs.FrameID;
			
			if( frame_id == 20 || frame_id == 30 )
			{
				Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SuccessHitFinalize ); // ヒット分岐フラグを立てる
				BMvTbl.SetFinalize( 256 );
				
				//相手との距離が近かったらベクトル収束させる
				local kyori = Battle_Std.GetEnemyDistance()/128;
				// _dp("\n kyori:"+kyori );
				if( kyori <= 200 && kyori >= 0 )
				{
					// 120〜320 : 普通にヒット　かなり遅くする
					// 320〜    : 牽制とかにヒット　500ぐらいまではあるな
					
					// 200以内収束させる感じで
					local conv_par = (kyori / 2) * 85 / 100;
					if( conv_par < 30 ) conv_par = 10;
					if( conv_par > 100 ) conv_par = 100;

					local vec = BMvTbl.GetVector();

					// _dp("\n conv_par:"+conv_par+" x:"+vec.x );
					vec.x = vec.x * conv_par / 100;
					// _dp(" -> "+vec.x );
					
					BMvTbl.SetVector( { x=vec.x, addx=vec.addx, flags=_Vector_Normal } );
					
				}
			}

			// １回目のヒットだけ引き寄せる処理
			if( BMvTbl.GetLP(0)==0 )
			{
				Battle_Std.SetPosition_DamageHanteiRect({ power=50, flags=(1<<1)|(1<<2) }); // 高さ無効、地上でも引き寄せ

				BMvTbl.SetLP(0,1);
			}
		}
	}
	function Finalize_After()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Skill_41236EX_Hit"]); //デフォ,[code,mv]...				
	}
}

t.Mv_Skill_41236EX_Hit <-
{
	flags = def_TmplFlags_ChangeStatusOnly //状態の移行のみ行う
	function Init_After()
	{
		Battle_Std.PassBeforeMoveCodeEx( 1, def_MC1_CSAntenGaesiSkill ); // 前のMVからフラグの引き継ぐ
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 30:
			BMvEff.CreateObject({ x=153*128, start_pat="41236EX_Tama", mvname="Mv_Obj_41236EX_Tama",});
			break;
		case 50:
			BMvTbl.JumpFrameID(200);
			break;
		}
	}
	function LastUpdate_After()
	{
		Battle_Std.CSAntenGaesi_DamageHosei(); // CSからの暗転返しで出したら補正をかける
	}	
}

t.Mv_Obj_41236EX_Tama <-
{
	function Init_After()
	{
		BMvTbl.SetPosition({ y=0 }); // 地面から
	}
}

t.Mv_63214EX_Hit_Camera <-
{
	function Init()
	{
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[20,50,20], type_in=1,  type_out=2 } );
		
	}
	function FrameUpdate_After()
	{
		local s = BMvTbl.GetMvStatus();
		
		if(s.CallCount==0)
		{
			local secall = 18;
			
			local camfallcall = 42;
			if(s.MvCount==camfallcall) BMvTbl.SetVector( { y=8500, addy=-150, flags=_Vector_Div } );
			
			if(s.MvCount==secall) BSound.SE_Play( { type=_SeType_Player, num=584 } );
		}
		
		if(s.MvCount > 300) BMvTbl.SetFinalize(256);
	}
	function LastUpdate_After()
	{
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );
	}
}

//Battle_Std.CreateObjectEX( { datatype=0, x=0, y=-150, mvname="Mv_63214EX_Hit_Camera", flags=_Position_ToolShift, objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround, objprocflags=_ObjProcFlags_EraseChangeParentMv } );

t.Mv_Obj_LightningStrikeObj <-
{
	function Init_After()
	{
		BSound.SE_Play( { type=_SeType_Player, num=16 } );
		
		local epos = Battle_Std.GetEnemyPosition();	
		local pos = BMvTbl.GetPosition();
		
		//BMvEff.ThrowRelease( { type=202, airrecover=0 } );
		
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			//Battle_Std.DrawDebugAttackInfo("x "+epos.x);
			
			//BMvTbl.SetPosition( { y=-150*128, x=pos.x } );
			
			enemy.pop();
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming() )
		{
			//BMvEff.ThrowParam( { pattern=304, y=15000, x=500 } );
			//BMvEff.ThrowRelease( { type=202, airrecover=0 } );
		}		
	}
	function LastUpdate_After()
	{
		Battle_Std.SetEnemyBoundSt({ settime = 25 });
		
		//BMvEff.ThrowRelease( { type=5, airrecover=0 } );
		//Battle_Std.ThrowRelease({ x=250, y=-300, type="きりもみ転倒", airrecover=45, flags=_ThrowRelease_NoGroundRecover });	
	}
}

t.Mv_Obj_63214EX_Hit_Obj <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ParentMove|_ObjFlags_NoRender|_ObjFlags_NoGround } );
	}
	function FrameUpdate_After()
	{
		local ballcall = 18;
		local strikecall = 40;
		local camfallcall = 35;
		
		local s = BMvTbl.GetMvStatus();
		
		if(s.CallCount==0)
		{
			if(s.MvCount==ballcall) BMvEff.CreateObject( { x=0, y=0, start_pat="J236Tama", flags=_Position_ToolShift } ); 
			if(s.MvCount==strikecall)
			{
				local eff = BMvEff.CreateObject( { x=0, y=0, mvname="Mv_Obj_LightningStrikeObj", flags=_Position_ToolShift } );
				if(eff.push())
				{
					BMvTbl.SetAngle( { angle=5000 } );
					BMvTbl.SetPosition( { y=-800*128 } );
				}
			}
		}
	}
}

t.Mv_Skill_63214EX_Hit <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		//BMvEff.SetStopTime( { time=45, stopme=0 } );
		
		local epos = Battle_Std.GetEnemyPosition();	
		
		BMvEff.ThrowParam( { pattern=304 } );
		
		BMvEff.ThrowRelease( { type=5, airrecover=0 } );

		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			//Battle_Std.DrawDebugAttackInfo("x "+epos.x);
			
			BMvTbl.SetPosition( { y=0, x=epos.x } );
			
			enemy.pop();
		}
		
		BMvTbl.SetLP(0,-1);
		
		if( BMvTbl.CheckFurimuki() )
		{
			//Battle_Std.DrawDebugAttackInfo("furimuki");
			
			BMvTbl.SetLP(0,1);
		}	
	}
	function FrameUpdate_After()
	{
		local epos = Battle_Std.GetEnemyPosition();	
		
		switch(Battle_Std.GetUpdateFrameID())
		{
			case 100:
				//BMvEff.ThrowRelease( { type=5, airrecover=0 } );
				
				local usevec = BMvTbl.GetLP(0);
				
				local p = BMvCore.GetEnemyCharaData();
				if( p.push() )
				{
					BMvTbl.SetVector( { x=3600*usevec, addx=-150*usevec, flags=_Vector_Bound } );
					
					p.pop();
				}
			break;
			case 101:	
				//Battle_Std.DrawDebugAttackInfo("x "+epos.x);
				local cam = Battle_Std.CreateObjectEX( { datatype=0, x=0, y=-500*128, mvname="Mv_63214EX_Hit_Camera", objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround, objprocflags=_ObjProcFlags_EraseChangeParentMv } );
				local ball = BMvEff.CreateObject( { x=0, y=-800*128, mvname="Mv_Obj_63214EX_Hit_Obj" } ); 
				if(ball.push())
				{
					BMvTbl.SetPosition( { x=epos.x } );
					
					ball.pop();
				}
				if(cam.push())
				{
					BMvTbl.SetPosition( { x=epos.x } );
					
					ball.pop();
				}
			break;
		}
		
	}
	function LastUpdate_After()
	{
		BMvTbl.SetMuki( _Direction_Auto );
	}
	
}

t.Mv_Skill_63214EX <- 
{
	function Init_After()
	{
		Battle_Std.MoveCodeEx.AddFlag( 2, def_MC2_SkillThrow );
	}
	function FrameUpdate_After()
	{

	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_63214EX_Hit"]); //デフォ,[code,mv]...
	}
}

//-----------------------------------------------------------------------------
// 41236SP攻撃
//-----------------------------------------------------------------------------

t.Mv_Obj_IW_eff1 <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop | _ObjFlags_FromParentStop  } );
		
		//BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ONCE補正
		BMvTbl.SetAngle( { angle=2500 } );
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_Obj_IW_eff2 <-
{
	function Init_After()
	{
		//BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ONCE補正
	}
}

t.Mv_Skill_236236SP <-
{
	function FrameUpdate_After()
	{
		if( Battle_Std.GetUpdateFrameID()==100 )
		{
			BMvEff.CreateObject( { x=0, y=-90, mvname="Mv_Obj_IW_AtkLase", flags=_Position_ToolShift } ); 
		}
		if( Battle_Std.GetUpdateFrameID()==50 )
		{
			Battle_Std.DrawBladeEffect( { x=-24, y=-236, pat="391ef_a", } );
		}
	}
}

t.Mv_Obj_IW_AtkLase <-
{
	function Init_After()
	{
		BSound.SE_Play( { type=_SeType_Player, num=17 } );
		
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop | _ObjFlags_FromParentStop  } );
		
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ONCE補正
				
		BMvEff.CreateObject( { x=0, y=-150, start_pat=206, mvname="Mv_Obj_IW_eff1" flags=_Position_ToolShift } ); 
		BMvEff.CreateObject( { x=0, y=-150, start_pat=207, mvname="Mv_Obj_IW_eff1" flags=_Position_ToolShift } ); 
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_Obj_41236EX_GarekiS <- 
{
	function Init_After() // 初回処理
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround  } );		

		BMvTbl.SetAngle( { angle_float=BMvEff.Random_F() } ); //てきとう
		local vx = (BMvEff.Random_Limit(2000)-1000)*3;
		local ry = BMvEff.Random_Limit(2000);
		local vy = -6500-ry;
		local frame = 40+BMvEff.Random_Limit(30);
		BMvTbl.SetVector( { x=vx, y=vy, addx=0, addy=-vy/frame, flags=_Vector_Div } );
	}
}

t.Mv_Skill_41236SP <- //インス技
{
	function Init_After() // 初回処理
	{
	}
	function FrameUpdate_After() // フレーム更新処理
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<3), CheckFrameID=2, EndFrameID=160, SetPattern="IWNoHold", flags=Def_JFIDNHB_CheckAllButton } ); // ButtonMask, CheckFrameID, SetPattern
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		switch( s.FrameID )
		{
		case 5: //つきさすところ
			if( s.isFrameUpdate )
			{
				BSound.SE_Play( { type=_SeType_Player, num=3 } ); //IFW
				local eff = BMvEff.CreateObject( { x=24, y=6, mvname="Mv_AtkObj_IW_AtkRect", flags=_Position_ToolShift } ); //判定とか
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround } );
					BMvEff.ObjType_Set( { type=_ObjType_FireBall } );
					Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定
					
					eff.pop();
				}
			}
			break;
		case 7: //つきさすところ
			if( s.isFrameUpdate )
			{
				BSound.SE_Play( { type=_SeType_Player, num=3 } ); //IFW
				local eff = BMvEff.CreateObject( { x=24, y=6, mvname="Mv_AtkObj_IW_AtkRectHold", flags=_Position_ToolShift } ); //判定とか
				if( eff.push() )
				{
					BMvEff.SetObjectFlags( { flags=_ObjFlags_EraseParentPatChange|_ObjFlags_NoGround } );
					BMvEff.ObjType_Set( { type=_ObjType_FireBall } );
					Battle_Std.MoveCode.AddFlag( def_MC_FireBall ); // 行動コード(飛び道具)を設定
					
					eff.pop();
				}
			}
			break;
		case 10: //ループ中
			if( s.CallCount==0 )
			{
				if ( s.MvCount<90 && s.MvCount%1 == 1 ) //だいたい1Fに１回呼ぶ
				{
					local pos = BMvEff.Random_PointRect( { sx=-500, sy=-100, ex=500, ey=20 } );
					BMvEff.CreateObject( { x=pos.x, y=pos.y, datatype=1, start_pat=283, mvname="Mv_Obj_41236EX_GarekiS", flags=_Position_ToolShift } );
				}
				else if ( s.MvCount<100 && s.MvCount%2 == 1 ) //だいたい2Fに１回呼ぶ
				{
					local pos = BMvEff.Random_PointRect( { sx=-400, sy=-100, ex=400, ey=20 } );
					BMvEff.CreateObject( { x=pos.x, y=pos.y, datatype=1, start_pat=283, mvname="Mv_Obj_41236EX_GarekiS", flags=_Position_ToolShift } );
				}
				else if ( s.MvCount<110 && s.MvCount%3 == 1 ) //だいたい3Fに１回呼ぶ
				{
					local pos = BMvEff.Random_PointRect( { sx=-300, sy=-100, ex=300, ey=20 } );
					BMvEff.CreateObject( { x=pos.x, y=pos.y, datatype=1, start_pat=283, mvname="Mv_Obj_41236EX_GarekiS", flags=_Position_ToolShift } );
				}
			}
			break;
		case 50: //終了
			if( s.isFrameUpdate ) Battle_Std.FinalizeWorthSkill(); //終了
			break;
		case 100:
			Battle_Std.NoCansel_NoAttackHit({ no_atk_hit = 1 }); //何かでキャンセルしなかった場合追撃不能にする
			Battle_Std.EnemyNoAttackHit(); 
			break;
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckDamageTiming_FrameID( 5 ) || Battle_Std.CheckDamageTiming_FrameID( 7) )//剣さすところがヒット
		{
			BMvEff.SetCamera_Quake( { time=30, type=0, clear=0, } ); //揺らし
			BMvEff.Slowmotion_Set( { time=30, power=5000 } ); //スロー
		}
	}
}
//	

t.Mv_AtkObj_IW_AtkRect <-
{
	function Init_After()
	{
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ONCE補正
	}
}

t.Mv_AtkObj_IW_AtkRectHold <-
{
	function Init_After()
	{
		BMvTbl.SetNoHoseiFlag( {  val=1, time=254, flag=_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } ); // ONCE補正
	}
}

//-----------------------------------------------------------------------------
// インフィニットワースＥＸＳ
//-----------------------------------------------------------------------------

//t.Mv_Skill_IWEXIST <- 
//{
//	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
//	function HitInterrupt_After()
//	{
//		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
//	}
//	function Finalize() // 
//	{
//		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_IWEXIST_Hit"]); //デフォ,[code,mv]...
//	}	
//}

t.Mv_Skill_IWEXIST_Hit_old <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function StepPhase( setphase=-1 )
	{
		if( setphase== -1)
		{
			BMvTbl.AddLP(0, 1);
			BMvTbl.SetLP(1, 0);		
		}
		else
		{
			BMvTbl.SetLP(0, setphase);
			BMvTbl.SetLP(1, 0);			
		}
	}
	
	function Init_After()
	{
		//Battle_Std.IWEXIST_CallOnePunch(); // 相手をMvBoundにする
	
		Battle_Std.InitIWExistSkill();

		BMvEff.ThrowParam( { pattern=304, x=600, y=0, } ); //敵の座標を設定

		local p = BMvCore.GetCaptureCharaData();
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //	
				//BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } ); //非表示にする
				Battle_Std.InitVector(); //とりあえず…
			BMvCore.PopCharaData(); //	
		}
		
		BMvEff.ThrowChara_SetJoint( 0 ); //くっつけない
		
		Battle_Std.CreateObjectEX( { datatype=0, x=0, y=0, mvname="Mv_IWEXIST_Camera_old", flags=_Position_ToolShift,
		objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround,
		objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
		initfunc = function()
		{
			BMvEff.SetExist( { level = _Exist_NoHantei } );
		}
		} );		
		
		//多分ここまではワンセットなのでは
		BMvTbl.SetPP(def_PP_Temp,0); //状態管理に使おう
		
		BMvTbl.SetLP(0,0); //フェイズ番号
		BMvTbl.SetLP(1,0); //フェイズカウンタ
	}
	function FrameUpdate_After()
	{
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		local mode = BMvTbl.GetLP(0); //状態
		local phasecnt = BMvTbl.GetLP(1); //カウンタ取得
		BMvTbl.AddLP(1,1); //1F進める		
		
		switch( mode )
		{
		case 0: //初期待機
			if( phasecnt>40 ) StepPhase();
			break;
		case 1: //タマを飛ばす
			if( phasecnt==0 )
			{
				//たまを飛ばす
				BMvEff.ThrowParam( { pattern=320, x=600, y=0, } );
				Battle_Std.DrawBladeEffect( { x=600, y=-250, pat="391ef_a100", } );
				
				// local p = BMvCore.GetCaptureCharaData();
				// if( p.IsDone )
				// {
					// BMvCore.PushCharaData( p ); //	
						// BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } ); //消していたのを戻す
					// BMvCore.PopCharaData(); //					
				// }			
			}
			break;
		case 150: //きった後
			if( phasecnt>200 ) StepPhase();
			break;
		case 151: //きった後
			if( phasecnt>300 ) StepPhase();
			break;
		}
		
		switch( Battle_Std.GetUpdateFrameID( s ) )
		{
		case 50: //かまえループ開始
			BSound.BGM_SetFade( { val=50, time=240 } );//BGMのフェードアウト
			Battle_Std.DrawBladeEffect( { x=-24, y=-236, pat="391ef_a", } );
			break;
		case 100: //きりはじめ
			//ハイド付近にカメラを固定
			
			StepPhase(100); //切った後にする 
			break;
		case 120: //剣をチャージ開始
			BSound.BGM_SetFade( { val=25, time=240 } );//BGMのフェードアウト
			BMvEff.SetCamera_Quake( { time=120, type=2, clear=0, } ); //揺らし
			break;
		case 150: //きった
			BMvEff.SetCamera_Quake( { time=255, type=2, clear=0, } ); //揺らし
			
			Battle_Std.CreateObjectEX( { x=80, y=0, pat="391ef_b", mvname="Mv_IWEXIST_Eff_391ef_b_old", flags=_Position_ToolShift,
				objectflags=_ObjFlags_EraseParentPatChange, //パターン変更で
				objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
			} );
			
			Battle_Std.CreateObjectEX( { x=80, y=0, mvname="Mv_Call_LightEff_old", flags=_Position_ToolShift,
				objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround,
				objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
			} );

			StepPhase(150); //すすめる
			
			local p = BMvCore.GetCaptureCharaData();
			if( p.IsDone )
			{
				BMvCore.PushCharaData( p );
					BMvTbl.SetVector( { x=-256, y=-64 } );
				BMvCore.PopCharaData();		
			}
			
			BMvEff.ThrowParam( { pattern=320, x=750, y=-150, } );

			
			break;
		case 250: //とどめ判定
			Battle_Std.IWExistSkill_FinishEffect(); //KOと同じような揺れやスローを呼ぶ

			StepPhase(250); //すすめる
			BMvEff.FadeProc_Set({type=0, time=[30,300,0] color=0x8D0017})
			break;
		case 300: //ホアイトアウト
			break;
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST_End" );
	}	
	function LastUpdate_After()
	{
		BMvEff.FadeProc_SetRenderFlag(1); // 0:カットインBG描画なし
		
		BMvEff.SetCamera_Quake( { time=0, type=2, clear=0, } ); //揺らし
		BMvEff.FadeProc_Set({type=0, time=[0,1,30] color=0x8D0017})
	
		//つかみ開放
		//BMvEff.SetCamera_Focus( { zoom=1.0, time=[0,0,30] } ); //カメラ固定
		BMvEff.ThrowParam( { x=100, y=-1224, } );
		BMvEff.ThrowRelease( { type="斜め下バウンド", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		Battle_Std.FinalizeIWExistSkill();
	}	
}

//演出中はこいつにカメラが固定される
t.Mv_IWEXIST_Camera_old <-
{
	function Init()
	{
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[60,999,60] } );
		//LP0
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //
				local mode = BMvTbl.GetLP(0);
			BMvCore.PopCharaData(); //

			//PP変化の瞬間のみ見る
			if( mode!= BMvTbl.GetLP(0) )
			{
				BMvTbl.SetLP(0,mode);
				// _dm("モード変更:"+mode);
				
				switch( mode )
				{
				case 0: //
					break;
				case 100: //構え開始
					//カメラ拡大
					BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[60,999,60] } );
					break;
				case 150: //きるところ
					break;
				}
			}
			
			//モード中常時やること
			switch( mode )
			{
			case 150: //
				//相手の方に移動開始
				local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
				if( enemy.IsDone ) // 有効かどうか一応チェック
				{
					local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
					//local angle_deg = posst.angle * 180; // 360度にしてみる（0.0-2.0 なのでx180で変換）
					//print( format( "角度：%f  距離：%d", angle_deg, posst.distance ) );
					
					local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = posst.distance/60 } );
					BMvTbl.SetVector( { x=v.x, y=v.y, flags=_Vector_DivKeep|_VecFlag_NoMuki } );							
				}
				break;
			case 151: //
				//相手の方に移動開始
				local enemy = BMvCore.GetNearEnemyCharaData(); // 相手情報取得
				if( enemy.IsDone ) // 有効かどうか一応チェック
				{
					local posst = BMvEff.GetPointStatus( { target=enemy } ); // 位置情報取得
					//local angle_deg = posst.angle * 180; // 360度にしてみる（0.0-2.0 なのでx180で変換）
					//print( format( "角度：%f  距離：%d", angle_deg, posst.distance ) );
					
					local v = BMvEff.GetVector_FromAngle( { angle = posst.angle, speed = posst.distance/200 } );
					local pow = 150;
					BMvTbl.SetVector( { x=v.x*pow/100, y=v.y, flags=_Vector_DivKeep|_VecFlag_NoMuki } );							
				}
				break;
			case 152: //
				Battle_Std.InitVector(); //ベクトル初期化
				break;
			case 300: //
				BMvTbl.SetFinalize(0); //さよなら
				break;
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );
		BMvEff.ResetViewCamera();
	}
}

t.Mv_IWEXIST_Eff_391ef_b_old <-
{
	function Init()
	{
		//BMvTbl.SetPattern("391ef_b");
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //
				local mode = BMvTbl.GetLP(0);
			BMvCore.PopCharaData(); //	
		
			//赤いのが出始めたらうんたん
			switch( Battle_Std.GetUpdateFrameID() )
			{
			case 100:
				local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
				BMvCore.PushCharaData( p ); //	
					BMvEff.SetCharaColor( { color=0x222222, intime=20, time=255, type=4} );
				BMvCore.PopCharaData(); //
				
				BMvEff.CreateObject( { mvname="Mv_IWEXIST_Eff_391ef_AtkRect_old" } ); //判定			
				break;
			}
			
			if( mode>= 300 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		BMvEff.SetCharaColor( { color=0x222222, time=0, type=0} );	
	}
}

t.Mv_IWEXIST_Eff_391ef_AtkRect_old <-
{
	function Init()
	{
		BMvTbl.SetPattern("391ef_AtkRect");
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //
				local mode = BMvTbl.GetLP(0);
			BMvCore.PopCharaData(); //	
		
			if( mode>= 250 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_Call_LightEff_old <-
{
	function Init()
	{
		//BMvTbl.SetPattern("391ef_b");
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvEff.SetExist( { level = _Exist_NoHantei } ); // 全ての判定チェックなし
	}
	function FrameUpdate()
	{
		//赤いのが出始めたらうんたん
		//local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		//BMvTbl.AddLP(0,1); //1F進める
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount%30==0 && s.MvCount!=BMvTbl.GetLP(0) )
		{
			BMvTbl.SetLP(0,s.MvCount); //処理したフレームを記憶
			
			Battle_Std.CreateObjectEX({ x=0, y=0, pat="IWE_Light", FrameID=[0,10,20],
				objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround,
			});		
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_Skill_IWEXIST <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function HitInterrupt_After()
	{
		BMvTbl.SetMuki(_Direction_Right); 
		
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize() // 
	{
		local rs = BMvTbl.GetMvRoundStatus();
		local enemyisDanger = false;
		local enemy = BMvCore.GetNearEnemyCharaData();
		if( enemy.IsDone )
		{
			BMvCore.PushCharaData( enemy );
			enemyisDanger = (BCMDTbl.GetHPRatio() <= 25);
			BMvCore.PopCharaData();
		}
		if( enemyisDanger )
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_IWEXIST_Hit"]); //デフォ,[code,mv]...
		}
		else
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_IWEXIST_Hit_old"]); //デフォ,[code,mv]...
		}
	}	
}

t.Mv_Obj_KermoneyLaser <-
{
	function Init_After()
	{
		BMvTbl.SetPrio( _CharaPrio_Near );
	}
}

t.Mv_Obj_KermoneyObj <-
{
	function Init_After()
	{
		//BMvEff.SetCamera_Quake( { time=150, type=2, clear=0, } );
		
		BMvTbl.SetMuki(_Direction_Right); 
	}
	function FrameUpdate_After()
	{
		local p = BMvCore.GetPlayerCharaData();
		local mvs = BMvTbl.GetMvStatus();
		
		local upframe_ID = Battle_Std.GetUpdateFrameID();
		
		switch( upframe_ID )
		{
		case 100: //ここから収束
			//BMvEff.CreateObject( { x=200, y=-300, mvname="Mv_Obj_KermoneyLaser", flags=_Position_ToolShift } ); 
			break;;
		}
		
		if(mvs.FrameID==100) 
		{
			local eff = BMvEff.CreateObject( { x=-40, y=-360, mvname="Mv_Obj_KermoneyLaser", flags=_Position_ToolShift } );
			if(eff.push())
			{
				BMvTbl.SetAngle({ angle=600});
				eff.pop();
			}
			
			BMvEff.SetCamera_Quake( { time=50, type=2, clear=0, } );
			
			//Battle_Std.PlayerSE_Play( 710 );
		}
		
		if(p.push())
		{
			switch( upframe_ID )
			{
				case 99:
					BMvTbl.SetLP(1,1); //1 is camera
					BMvEff.SetCamera_Quake( { time=50, type=2, clear=0, } );
					break;
				case 101: //ここから収束
					//Battle_Std.DrawDebugAttackInfo("ne");
					BMvTbl.SetLP(0,1);
					break;;
				case 102: //ここから収束
					//Battle_Std.DrawDebugAttackInfo("ne");
					BMvTbl.SetLP(0,2);
					break;;
				case 199:
					Battle_Std.PlayerSE_Play(712);
					break;
				case 200:
					//Battle_Std.PlayerSE_Play( 712 );
					break;
			}
			p.pop();
		}
	}
}

t.Mv_Skill_IWEXIST_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function StepPhase( setphase=-1 )
	{
		if( setphase== -1)
		{
			BMvTbl.AddLP(0, 1);
			BMvTbl.SetLP(1, 0);		
		}
		else
		{
			BMvTbl.SetLP(0, setphase);
			BMvTbl.SetLP(1, 0);			
		}
	}
	
	function Init_After()
	{
		//Battle_Std.IWEXIST_CallOnePunch(); // 相手をMvBoundにする
	
		BSound.SE_Play( { type=_SeType_Player, num=585 } );
		
		Battle_Std.InitIWExistSkill();
		//BSound.SE_Play( { type=_SeType_Player, num=610 } ); //発動
		//BSound.SE_Play( { type=_SeType_Player, num=610 } ); //発動
		
		BMvEff.Cockpit_SetView( { mode=0 } );

		BMvEff.ThrowParam( { pattern=304, x=900, y=0, } ); //敵の座標を設定

		local p = BMvCore.GetCaptureCharaData();
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //	
				//BMvEff.SetObjectFlags( { flags=_ObjFlags_NoRender } ); //非表示にする
				Battle_Std.InitVector(); //とりあえず…
			BMvCore.PopCharaData(); //	
		}
		
		BMvEff.ThrowChara_SetJoint( 0 ); //くっつけない
		
		Battle_Std.CreateObjectEX( { datatype=0, x=0, y=0, mvname="Mv_IWEXIST_Camera", flags=_Position_ToolShift,
		objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoRender|_ObjFlags_NoGround,
		objprocflags=_ObjProcFlags_EraseChangeParentMv, //行動変更で消滅
		initfunc = function()
		{
			BMvEff.SetExist( { level = _Exist_NoHantei } );
		}
		} );		
		
		//多分ここまではワンセットなのでは
		BMvTbl.SetPP(def_PP_Temp,0); //状態管理に使おう
		
		BMvTbl.SetLP(0,0); //フェイズ番号
		BMvTbl.SetLP(1,0); //フェイズカウンタ
		BMvTbl.SetLP(8,0); //音声タイミング
		BSound.BGM_SetFade( { val=50, time=240 } );//BGMのフェードアウト
		BMvEff.CreateObject( { x=400, y=0, mvname="Mv_Obj_KermoneyObj", flags=_Position_ToolShift } ); 
	}
	function FrameUpdate_After()
	{
		local lp0 = BMvTbl.GetLP(0);
		switch(lp0)
		{
			case 1:
				Battle_Std.IWExistSkill_FinishEffect(); //KOと同じような揺れやスローを呼ぶ

				BSound.SE_Play( { type=_SeType_Player, num=587 } ); //ﾊｧﾊｧ
			
				//StepPhase(250); //すすめる
				BMvEff.FadeProc_Set({type=0, time=[30,300,0] color=0x8D0017});
				
				BMvTbl.SetLP(0,-1); 
			break;
			case 2:
				BMvTbl.SetFinalize(0);
				break;
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST_End" );
	}	
	function LastUpdate_After()
	{
		BMvEff.FadeProc_SetRenderFlag(1); // 0:カットインBG描画なし
		
		BMvEff.SetCamera_Quake( { time=0, type=2, clear=0, } ); //揺らし
		BMvEff.FadeProc_Set({type=0, time=[0,1,30] color=0x8D0017})
		BMvEff.Cockpit_SetView( { mode=1 } );
		//つかみ開放
		//BMvEff.SetCamera_Focus( { zoom=1.0, time=[0,0,30] } ); //カメラ固定
		BMvEff.ThrowParam( { x=100, y=-1224, } );
		BMvEff.ThrowRelease( { type="斜め下バウンド", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
		Battle_Std.FinalizeIWExistSkill();
	}	
}

t.Mv_Skill_IWEXIST_End <- {};
	

//演出中はこいつにカメラが固定される
t.Mv_IWEXIST_Camera <-
{
	function Init()
	{
		BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[60,999,60] } );
		//BMvTbl.SetPosition( { x=0, y=0 } );
		//LP0
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if(p.push())
		{
			local lp1 = BMvTbl.GetLP(1);
			p.pop();
			
			switch(lp1)
			{
				case 1:
					//BMvEff.SetCamera_Focus( { charapos=1, zoom=1.0, time=[60,999,60] } );
					//BMvTbl.SetPosition( { x=500, flags=_Position_Add|_Position_ChangeMuki|_Position_CaptureShift } );
					//BMvEff.SetCamera_Focus( { charapos=0, zoom=1.0, time=[60,999,60] } );
					
					BMvTbl.SetVector( { x=4000, y=0, addx=-100, flags=_Vector_Div } );
					
					local e_muki = BMvTbl.GetMuki();
					local enemy = BMvCore.GetNearEnemyCharaData(); // 敵情報を得る
					local yoff = 0;
					local xoff = 0;

					if( enemy.push() )
					{
						local epos = BMvTbl.GetPosition();

						yoff = 0;
							
						xoff = 1500*e_muki;
						//Battle_Std.DrawDebugAttackInfo("yoff "+yoff+" xoff "+xoff+" e xpos "+epos.x);
						
						//BMvEff.SetCamera_Focus( { charapos=1, zoom=3.0, time=[60,999,60] } );
						
						
						enemy.pop();
					}
					
					if( p.IsDone )
					{
						if( BMvCore.PushCharaData( p ) )
						{
							BMvTbl.SetLP(1,-1);
						}
						BMvCore.PopCharaData();
					}	
					
				break;
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		BMvEff.SetCamera_Focus( { time=[0,0,0] } );
		BMvEff.ResetViewCamera();
	}
}

t.Mv_IWEXIST_Eff_391ef_b <-
{
	function Init()
	{
		//BMvTbl.SetPattern("391ef_b");
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //
				local mode = BMvTbl.GetLP(0);
			BMvCore.PopCharaData(); //	
		
			//赤いのが出始めたらうんたん
			switch( Battle_Std.GetUpdateFrameID() )
			{
			case 100:
				local p = BMvCore.GetPlayerCharaData(); // 操作親の情報を得る
				BMvCore.PushCharaData( p ); //	
					BMvEff.SetCharaColor( { color=0x222222, intime=20, time=255, type=4} );
				BMvCore.PopCharaData(); //
				
				BMvEff.CreateObject( { mvname="Mv_IWEXIST_Eff_391ef_AtkRect" } ); //判定			
				break;
			}
			
			if( mode>= 300 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
	function LastUpdate()
	{
		BMvEff.SetCharaColor( { color=0x222222, time=0, type=0} );	
	}
}

t.Mv_IWEXIST_Eff_391ef_AtkRect <-
{
	function Init()
	{
		BMvTbl.SetPattern("391ef_AtkRect");
	}
	function FrameUpdate()
	{
		//親のLPみて変化
		local p = BMvCore.GetPlayerCharaData(); // プレイヤーの情報を得る
		if( p.IsDone )
		{
			BMvCore.PushCharaData( p ); //
				local mode = BMvTbl.GetLP(0);
			BMvCore.PopCharaData(); //	
		
			if( mode>= 250 )
			{
				BMvTbl.SetFinalize(0);
			}
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

t.Mv_Call_LightEff <-
{
	function Init()
	{
		//BMvTbl.SetPattern("391ef_b");
		BMvTbl.SetLP(0,0); //カウンタ初期化
		BMvEff.SetExist( { level = _Exist_NoHantei } ); // 全ての判定チェックなし
	}
	function FrameUpdate()
	{
		//赤いのが出始めたらうんたん
		//local mvcnt = BMvTbl.GetLP(0); //カウンタ取得
		//BMvTbl.AddLP(0,1); //1F進める
		
		local s = BMvTbl.GetMvStatus(); // ステータス取得
		if( s.MvCount%30==0 && s.MvCount!=BMvTbl.GetLP(0) )
		{
			BMvTbl.SetLP(0,s.MvCount); //処理したフレームを記憶
			
			Battle_Std.CreateObjectEX({ x=0, y=0, pat="IWE_Light", FrameID=[0,10,20],
				objectflags=_ObjFlags_NoCamera|_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround,
			});		
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}




t.Mv_Skill_63214SP <- 
{
	function Init_After()
	{
		BMvEff.PcAfterImage_Set( { type=1, range=50, delay=3, color=0xFFD50000 });
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Param1 & 32 の時、足無敵
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_63214SP_Hit"]); //デフォ,[code,mv]...
	}
}

t.Mv_Skill_63214SP_Hit <- 
{
	function Init_After()
	{
		local pos = BMvEff.GetCameraPosition( { x=0, y=0, flags=_GetPos_ViewCamera | _GetPos_Offset | _GetPos_NoMuki } );

		BMvEff.ResetCamera(); //カメラ初期化
		BMvEff.ResetViewCamera();
		
		BMvTbl.SetPosition( { x=-pos.x, y=0, flags= _Position_ChangeMuki } );
		
		// BMvEff.SetCamera_Clipping( 0 ); //画面端のクリッピング補正を切る
		
		BMvEff.SetObjectRender( { type=1 } ); //設置物がワープしてしまうので演出中は消す
	}
	function LastUpdate_After()
	{
		BMvTbl.SetPosition( { y=0 } );
		Battle_Std.FinalizeWorthSkill();
	}
};




HYDEX_MoveTable <- Battle_Std.MakeMoveTable( t, HYDEX_CommandTable, Def_ChrNo_HydEX );
__dofile__("./data/HydEX/HydEX_se_category.txt"); //ＳＥ定義
