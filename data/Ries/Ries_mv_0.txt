local t = {};
local chrFunc = {};

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------

chrFunc.DragonInstall <- false;

const CDef_Rie_PP_DragonInstall = 0;
const CDef_Rie_PP_InstallLimit = 0;
const CDef_Rie_PP_InstallTimer = 800;

const Installed = 0;
const InstallTimer = 1000;

local Install = {};

// Neutral Jump Drift, stolen from Eltnum
local set_JumpCtrlVector = function()
{
    local vec = BMvTbl.GetVector();

    if( (vec.y + vec.addy ) >= 0 )
    {
        return;
    }

    local x = 0;
    local plus_x = 96; // Move by this every frame
    if( ( BMvTbl.CheckStickHold( (1<<4) | (1<<7) | (1<<1) ) ) && vec.x > -1000 ) x -= plus_x; // Check left directions and limit
    if( ( BMvTbl.CheckStickHold( (1<<6) | (1<<9) | (1<<3) ) ) && vec.x <  1000 ) x += plus_x; // Check right directions and limit

    if( x )
    {
        vec.x += x; //
        BMvTbl.SetVector( { x=vec.x, flags=_Vector_Normal } );
    }
}


//-----------------------------------------------------------------------------
// Universal Mechanics
//-----------------------------------------------------------------------------

t.Mv_Startup <-
{
    function Init_After()
    {
        if( Battle_Std.CheckTrainingCharaGaugeMode() ) // Check if we're in training with character specifics on
        {
            BMvEff.GRD_SetBreak( 0, def_GRDBF_NormalAtkDmg, def_GRDBF_NormalAtkDmg ); // GRD Break
            BMvTbl.SetPP(CDef_Rie_PP_DragonInstall, 1); // Installed
            BMvTbl.SetPP(CDef_Rie_PP_InstallTimer, 999999); // Practically Infinite Timer
			BMvTbl.SetLP(10,1);
            BMvEff.CreateObject( { mvname="Mv_Obj_BeastMode" } );
        }
    }
}

t.Mv_Neutral <- // TODO I need to get rid of this
{
    function FrameUpdate_After()
    {
        local s = BMvTbl.GetMvStatus();
        if ( (s.FrameID == 10) && (s.MvCount >= 200) && (BMvEff.Random_Limit(90) == 1) ) // Randomize Taunt
        {
            BMvTbl.JumpFrameID( 20 );
        }
    }
}

t.Mv_Walk_F <- { function FrameUpdate_After() { BMvTbl.SetVector( { x=1000, y=0, addx=0, addy=0, flags=_Vector_Normal } ); } }
t.Mv_Walk_B <- { function FrameUpdate_After() { BMvTbl.SetVector( { x=-880, y=0, addx=0, addy=0, flags=_Vector_Normal } ); } }

t.Mv_Dash_F <-
{
    function FrameUpdate_After()
    {
        local di = (BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) == 1)? 1 : 0; // Faster if Installed
        if(di) { BMvTbl.SetVector( { x=5000, flags=_Vector_Normal } ); }
    }
}

t.Mv_Dash_B <-
{
    function FrameUpdate_After()
    {
        local di = (BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) == 1)? 1 : 0; // Faster if Installed
        if(di)
        {
            switch( Battle_Std.GetUpdateFrameID() )
            {
            case 10:
                BMvTbl.SetVector( { x=-4000, flags=_Vector_Normal});
                break;
            }
        }
    }
}

t.Mv_Jump_N <- { function FrameUpdate_After() : (set_JumpCtrlVector) { set_JumpCtrlVector(); } } // Allow the drift function


// Need to figure out why these don't work, it's probably obvious
// t.MultiJump_F <- { function FrameUpdate_After() : (set_JumpCtrlVector) { set_JumpCtrlVector();         BMvEff.AttackInfoString_Set({ word = "F" });
 // } } // Allow the drift function
// t.MultiJump_N <- { function FrameUpdate_After() : (set_JumpCtrlVector) { set_JumpCtrlVector();         BMvEff.AttackInfoString_Set({ word = "wt" });
 // } } // Allow the drift function
// t.MultiJump_B <- { function FrameUpdate_After() : (set_JumpCtrlVector) { set_JumpCtrlVector();         BMvEff.AttackInfoString_Set({ word = "what" });
 // } } // Allow the drift function
// t.MultiJumpCancel_F <- { function FrameUpdate_After() : (set_JumpCtrlVector) { set_JumpCtrlVector(); } } // Allow the drift function
// t.MultiJumpCancel_N <- { function FrameUpdate_After() : (set_JumpCtrlVector) { set_JumpCtrlVector(); } } // Allow the drift function
// t.MultiJumpCancel_B <- { function FrameUpdate_After() : (set_JumpCtrlVector) { set_JumpCtrlVector(); } } // Allow the drift function

t.Mv_ConvertCharge <-
{
    function FrameUpdate_After()
    {
        if ( BMvEff.GRD_GetJudgeResult() > 0 ) // Vorpal Effect: Concentration increases EXS gauge
        {
            local player = BMvCore.GetPlayerCharaData();
            if( player.IsDone )
            {
                BMvCore.PushCharaData( player );
                local HP = BCMDTbl.GetHPRatio(); // Gain proportional to HP lost
                local GRD = BMvEff.GRD_CheckStock( { val=-1 } ); // Gain proportional to GRD count
                local distance = ( Battle_Std.GetEnemyDistance() / 10000 ); // Gain proportional to opponent proximity
                //BMvEff.AttackInfoString_Set({ word = HP });
                local SPadd = 25 - (HP * 0.25) + (GRD * 4) + (8 - (distance * 0.45) ); // Quick Maths
                BMvEff.SetSpGauge( { value=SPadd,limitval=0.0, } );
                //BMvEff.AttackInfoString_Set({ word = SPadd});
                BMvCore.PopCharaData();
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Base Attacks
//-----------------------------------------------------------------------------

t.Mv_Atk_Std6B <-
{
    function FrameUpdate_After()
    {
        Battle_Std.JumpFrameID_NotHoldButton({ mask=(1<<1), checkid=[200], jumpid=[202], endid=250 }); // Jump to frame ID 202 if 1 (B) is not held
    }
}

t.Mv_Atk_Std6C <-
{
    function FrameUpdate_After()
    {
        Battle_Std.JumpFrameID_NotHoldButton({ mask=(1<<2), checkid=100, jumpid=105, }); // Jump to frame ID 105 if 2 (C) is not held
        local s = BMvTbl.GetMvStatus();
        if( (s.FrameID==50 || s.FrameID==500) && (BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) == 1) ) // Check if we're installed on either version of the move for more distance
        {
            BMvTbl.SetVector( { addx=10, y=-600, addy=55, flags=_Vector_Normal|_VecFlag_Add } );
        }
    }
}

t.Mv_Atk_AirC <-
{
    function FrameUpdate_After()
    {
		Battle_Std.JumpFrameID_NotHoldButton({ mask=(1<<2), checkid=[100,200], jumpid=[101,201], endid=250 });

		local di = (BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) == 1)? 1 : 0;
		local s = BMvTbl.GetMvStatus();
		if (di && s.FrameID==888) { BMvTbl.JumpFrameID(999); ; };
    }
}

t.Mv_Atk_DashStdC <-
{
    function HitInterrupt()
    {
        BMvTbl.SetVector( { x=-500, flags=_Vector_Normal|_VectFlag_Add } ); // Add some slowdown on hit for some combo consistency
    }
}

t.Mv_Skill_SSRelayAtk <- // Steer Ender
{
    function FrameUpdate_After()
    {
        switch( Battle_Std.GetUpdateFrameID() )
        {
        case 100:
            local isDirectSS = BMvTbl.GetLPEx(1,1); // TODO I don't remember what any of this is for
            if( isDirectSS )
            {
                local now_vec = BMvTbl.GetVector();
                local vec_x = Battle_Std.GetEnemyDistance()/8 - now_vec.x;

                if( vec_x < -3500 ) vec_x = -3500;
                if( vec_x > 1000 ) vec_x = 1000;
                BMvTbl.SetVector({ x=vec_x, flags=_VecFlag_Add });
                local xmax = now_vec.x + vec_x - 4000;
                BMvTbl.SetVector_MaxX( xmax );
            }
            break;
        }
    }
}


t.Mv_Throw_F_Hit <- // Ground Throw Hit
{
    function Init_After()
    {
        Battle_Std.SetThrowEnemyMuteki( 254 ); // Set invulnerability for opponents during throws
    }
    function FrameUpdate_After()
    {
        local enemy = BMvCore.GetEnemyCharaData(); // For hooking onto the enemy
        local di = (BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) == 1)? 1 : 0; // Are we installed?

        switch( Battle_Std.GetUpdateFrameID() ) // Check (Key)Frame ID
        {
        case 100:
            if( enemy.push() ) // Push this code block on the opponent
            {
                BMvTbl.SetMuki( _Direction_Auto ); // Fix the opponent's facing direction
                enemy.pop(); // We're done with the opponent
            }
            break;
        case 800:
            if ( di ) // Installed, we're changing the attack parameters
            {
                BMvEff.CreateObject( { mvname="Mv_Obj_ThrowAtk" } );
                BMvEff.ThrowParam( { pattern = 324, x=120, y=-800 } );
                BMvEff.ThrowRelease( { type="真下MBバウンド", airrecover=0, flags=_ThrowRelease_NoGroundRecover } );
                // TODO I wanted the camera to not move like how it was before...
            }
            else
            {
                BMvEff.ThrowRelease( {type="空ガード強", airrecover=0, flags=_ThrowRelease_NoGroundRecover } ); // Normal Hit
            }
            break;
        case 1100:
            if ( !di )
            {
                Battle_Std.SetThrowEnemyMuteki( 0 ); // Set invulnerability
            }
            else
            {
                Battle_Std.SetThrowEnemyMuteki( 1 ); // Enemy can be hit again
            }
            break;
        }
    }
}

t.Mv_Obj_ThrowAtk <- // Lazy and bad way to do Beast Mode Throw Damage. I should do it the same way I did air throws but that'll wait
{
    function FrameUpdate_After()
    {
        Battle_Std.SetPos_MarkingEnemy(); // Track Enemy
        local enemy = BMvCore.GetNearEnemyCharaData();
        if( enemy.push() ) // Apply code block to enemy
        {
            BMvEff.SetCharaFlash( { color = 0xFFF257, type = 0, time = 30 } ); // Add golden flash effects
            BMvEff.SetCharaColor( { color = 0xFFF257, type = 0, intime = 60, time = 60 } );
            enemy.pop(); // Done with enemy
        }
    }
}

t.Mv_Throw_A <- // Air Throw
{
    function HitInterrupt() // When hit by the hitbox
    {
        local enemy = BMvCore.GetNearEnemyCharaData();
        local isBMCapture = false;
        if( enemy.push() )
        {
            local hs = BtlMvStd.GetBoundStatus();
            isBMCapture = ((hs.isCapture&(1<<1))!=0);
            enemy.pop();
        }
        BMvTbl.SetLP(0,0); // Set a LP variable 0 to 0 to indicate we aren't doing a combo throw by default
        if( isBMCapture ) BMvTbl.SetLP(0,1); // Set to 1 if we are doing a combo starter throw

        Battle_Std.SetThrowHitFinalize(256);
    }
}

t.Mv_Throw_A_Hit <-
{
    function FrameUpdate_After()
    {
        local s = BMvTbl.GetMvStatus(); // Check current frame ID

        if( s.FrameID==30 )
        {
            local jumpid = ( BMvTbl.GetLP(0)==1 )? 60 : 50; //Combo vs Raw
            BMvTbl.JumpFrameID(jumpid); // Jump according to combo/raw (Both are the same for Riesbyfe but I didn't manage to streamline it)
            if ( Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CounterHit ) || Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_GRDBreakAttack ) ) // We're checking if this GRD breaks or Counters as a starter for different properties
                {
                    BMvEff.AttackInfoString_Set({ word="THROW COUNTER"}); // Announce it
                    Battle_Std.PlayerSE_Play( 23 );
                    Battle_Std.CreateObjectEX( { x=18000, y=-30000, datatype=1, pat=977} );
                    Battle_Std.CreateObjectEX( { x=18000, y=-30000, datatype=1, pat=136} );
                }
        }

        local di = (BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) == 1)? 1 : 0;
        if( s.isFrameUpdate && ( s.FrameID == 50 || s.FrameID == 60 ) )
        {
            if ( (Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CounterHit ) || Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_GRDBreakAttack ) ) || di ) // Checking if we Countered, or Beast Mode
            {
                local enemy = BMvCore.GetNearEnemyCharaData();
                {
                    if( enemy.push() )
                    {
                        BMvEff.SetCharaFlash( { color = 0xFFF257, type = 0, time = 30 } );
                        BMvEff.SetCharaColor( { color = 0xFFF257, type = 0, intime = 60, time = 60 } );
                    }
                } //se 241 is good pilebukn
                enemy.pop();
                BMvEff.ThrowParam( { pattern = 324, x=120, y=-80 } );
                BMvEff.ThrowRelease( { type="斜め下MBバウンド", airrecover=0, flags=_ThrowRelease_NoGroundRecover } ); // Spike throw TODO USE NEW UZUKI VECTOR
                local counter = 1;
            }
            else // Regular air throw
            {
                BMvEff.ThrowParam( { pattern = 324, x=120, y=-80 } );
                BMvEff.ThrowRelease( { type="鋭角斜め下バウンド", flags=_ThrowRelease_NoGroundRecover|_ThrowRelease_NoAttackHit } );
                local enemy = BMvCore.GetNearEnemyCharaData();
                {
                    if( enemy.push() )
                    {
                        BMvTbl.SetHitStop( 0 ); // Minimize any hitstop if possible
                        enemy.pop();
                    }
                }
            }
        }
        if ( s.FrameID==70 && Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_CounterHit ) )
        {
            BMvTbl.SetVector( { addx=5, addy=20, flags=_Vector_Normal|_VecFlag_Add } ); // Fall faster
        }
        if ( s.FrameID==70 && di )
        {
            BMvTbl.SetVector( { x=0, flags=_Vector_Normal } ); // Negate backwards momentum
            BMvTbl.SetVector( { addy=30, flags=_Vector_Normal|_VecFlag_Add } );
        }
    }
}

//-----------------------------------------------------------------------------
// Special Moves
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Pile Arcato - 236
//-----------------------------------------------------------------------------

local maketmpl_PileArcato = function( param={} )
{
    local ret_tmpl = {}

    local mvparam = {
        cache = 0, // Hitgrab Switch
        hold = 0, // Can IC?
    }

    switch( param.type )
    {
    case "A":
        mvparam.cache = "236A_Hit";
        break;
    case "B":
        mvparam.cache = "236B_Hit";
        mvparam.hold = 1;
        break;
    case "EX":
        mvparam.cache = "236EX_Hit";
        break;
    }

    ret_tmpl.Init_After <- function() : (mvparam)
    {
        Battle_Std.CallAddSkillCache( mvparam.cache, 8 ); // Following Patstr, rest
        Battle_Std.MoveCode.AddFlag( def_MC_Sousai|def_MC_Sousai_NoSubHitCount ); // Offset Occurs
    }

    ret_tmpl.FrameUpdate_After <- function() : (mvparam)
    {
        Battle_Std.CheckSousai(); // Offsets if def_MC_Sousai
        if( mvparam.hold )
        {
            Battle_Std.SetPattern_NotHoldButton({ ButtonMask=(1<<1), CheckFrameID=100, EndFrameID=150, SetPattern="236B_Norm" } ); // Goes to 236B_Norm pattern if 1 (B) is not held
        }
    }

    ret_tmpl.HitInterrupt <- function()
    {
        local s = BMvTbl.GetMvStatus();
        if( s.FrameID==10 )
        {
            Battle_Std.SetThrowHitFinalize(256); // Successful Hit ID
        }
    }

    ret_tmpl.Finalize <- function() : (mvparam)
    {
        Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_"+mvparam.cache]); // Go to Neutral on whiff or to the switched ender move if we have SetThrowHitFinalize 256 enabled
    }

    return ret_tmpl;
}

local maketmpl_PileArcatoHit = function( param={} )
{
    local ret_tmpl = {}

    local mvparam = {
        cache = 0, // Version
        can = 0, // Cancellable?
        isEX = 0, // Is EX?
        tp = 0, // Throw Parameters
    }

    switch( param.type )
    {
    case "A":
        mvparam.cache = "236A_Hit";
        mvparam.tp = { pattern=331, x=320, y=0, };
        mvparam.can = 1; // EX Cancellable
        break;
    case "B":
        mvparam.cache = "236B_Hit";
        mvparam.tp = { pattern=331, x=350, y=0, };
        break;
    case "EX":
        mvparam.cache = "236EX_Hit";
        mvparam.isEX = true;
        break;
    }

    ret_tmpl.flags <- def_TmplFlags_NoAddComboRate; // Don't Add to Combo

    ret_tmpl.Init <- function() : (mvparam)
    {
        BMvEff.ThrowChara_SetJoint( 0 ); // Throw state
        BMvTbl.SetPattern(mvparam.cache); // Set version
        Battle_Std.CallSkillSoonCache( 512, 25 ); // hell if I know
        Battle_Std.PassHitMoveCodes(); // MvCode takeover at hit branch

        // 236 series looks weird all the way in the corner on hit.
        // We're going to space the players away from the corner on hit just like in MBAA
        // so that we can see the effects and characters better instead of being offscreen.
        local pos = BMvTbl.GetPosition();
        local p_muki = BMvTbl.GetMuki(); // Get facing directoin
        local corner_distance = def_POS_GamenHajiX - (-pos.x*p_muki); // Calc distance to corner
        local enemy = BMvCore.GetEnemyCharaData();
        if( enemy.push() ) // Hook code onto enemy
        {
            local e_muki = BMvTbl.GetMuki(); // Get enemy facing direction
            enemy.pop(); // Done with the enemy
            if( corner_distance > 495000 && p_muki!=e_muki ) // If we're a certain distance to the corner and they're not facing the same direction...
            {
                BMvTbl.SetPosition( { x=-20000*p_muki, flags=_Position_Add } ); // Move away from the corner a bit
                if (enemy.push() ) // Hook onto enemy
                {
                    BMvTbl.SetPosition( { x=-20000*p_muki, flags=_Position_Add } ); // Do the same to the enemy
                    enemy.pop(); // Done with enemy
                }
            }
        }

        if (!mvparam.isEX) { // Imagine my shock that the order doesn't seem to matter
            BMvEff.ThrowChara_SetCamera( 1 ); // Lock camera
            BMvTbl.SetPosition( { addx=-100 } );
            BMvEff.ThrowParam( mvparam.tp );
            Battle_Std.MoveCode.AddFlag( def_MC_Atk );
        }
    }

    ret_tmpl.FrameUpdate_After <- function() : (mvparam)
    {
        switch( Battle_Std.GetUpdateFrameID() )
        {
        case 250:
            if (mvparam.isEX) {
                local eff = BMvEff.CreateObject( { start_pat=151 } ); // Hit effect
                if( eff.push() ) // Hook onto the effect
                {
                    BMvTbl.SetAngle( { angle = 7500} ); // Set transformations
                    BMvTbl.SetPosition ( { y = -80000} ) ;
                    BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround} ); // Don't forcibly snap above the floor
                    eff.pop(); // Done with the effect
                }
            }
            break;
        case 512:
            if (mvparam.isEX) { // For the super:
                BMvEff.SetCamera_Quake( { time=23, type=2, clear=0, } ); // Shake the camera both x/y
                BMvEff.Slowmotion_Set( { time=30, power=6666 } );
            } else {
                BMvEff.ThrowRelease( { type="追撃ダウン", airrecover=0, flags=_ThrowRelease_NoGroundRecover|_ThrowRelease_NoWallRecover|_ThrowRelease_NoVecTimeHosei } ); // Normal pilebunker
                if (mvparam.can) Battle_Std.MoveCodeEx.AddFlag(2, def_MC2_EnableCVO_OnlyCS); // Allow it to EX cancel (236A only)
            }
            break;
        case 560:
            if (mvparam.isEX) {
                BMvEff.ThrowRelease( { type="追撃ダウン", airrecover=0, flags=_ThrowRelease_NoGroundRecover|_ThrowRelease_ReverseVec|_ThrowRelease_NoAttackHit|_ThrowRelease_NoWallRecover|_ThrowRelease_NoVecTimeHosei } )
                BMvTbl.SetMuki( _Direction_Reverse ); // This version sideswaps
            }
            break;
        }
    }

    ret_tmpl.LastUpdate_After <- function() : (mvparam)
    {
        Battle_Std.NoCansel_NoAttackHit(); // Cannot followup
        if (mvparam.isEX) {
            Battle_Std.ThrowMv_CanselRelease( { pat=353, x=100, y=0, type="きりもみ転倒", airrecover=0 } );
        } else {
            Battle_Std.ThrowMv_CanselRelease( { pat=320, x=250, y=-150, type="きりもみ転倒", airrecover=0 } );
        }
    }

    ret_tmpl.Finalize <- function()
    {
        BMvTbl.SetNextMoveTable( "Mv_Neutral" ); // Go back to Neutral... just in case
    }

    return ret_tmpl;
}

// Use these templates for these moves
t.Mv_Skill_236A <- maketmpl_PileArcato( { type="A" } );
t.Mv_Skill_236B <- maketmpl_PileArcato( { type="B" } );
t.Mv_Skill_236EX <- maketmpl_PileArcato( { type="EX" } );

t.Mv_236A_Hit <- maketmpl_PileArcatoHit( { type="A" } );
t.Mv_236B_Hit <- maketmpl_PileArcatoHit( { type="B" } );
t.Mv_236EX_Hit <- maketmpl_PileArcatoHit( { type="EX" } );

//-----------------------------------------------------------------------------
// Press Attacca - 623 (Aftact isn't a real term)
//-----------------------------------------------------------------------------

t.Mv_Skill_623EX <- //This is really butchered and scuffed especially in the ha6 (set pattern 0)
{
    function FrameUpdate_After()
    {
        Battle_Std.SetHitMuteki( 1, 32, _HitCheckFlag_Legs ); // Invulnerability check
        switch( Battle_Std.GetUpdateFrameID() )
        {
        case 200:  // Frame ID
            if ( Battle_Std.CheckEnemyisDamage() )
            {
                BMvTbl.SetPattern("623EX_JHit");
            }
            break;
        }
    }
    function HitInterrupt_After()
    {
        if( Battle_Std.CheckDamageTiming() ) //Still dunno what this does
        {
            Battle_Std.SetPosition_DamageHanteiRect({ power=50 });
        }
    }
    function Finalize()
    {
        Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_623EX_JHit"]); //デフォ,[code,mv]...
    }
}

t.Mv_Skill_623EX_JHit <-
{
    flags = def_TmplFlags_NoAddComboRate // nani desu
    function Init_After()
    {
        Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_SetMutekiDamage ); // nani desu
    }
    function LastUpdate_After()
    {
        Battle_Std.NoCansel_NoAttackHit(); // nani desu
        Battle_Std.CSAntenGaesi_DamageHosei(); // CSからの暗転返しで出したら補正をかける
    }
}

//-----------------------------------------------------------------------------
// Wrist Staccato - 214
//-----------------------------------------------------------------------------

local maketmpl_WristStaccato = function( param={} )
{
    local ret_tmpl = {}

    local mvparam = {
        IC = 0,
        SP = 0, // Set Pattern
    }

    switch( param.type )
    {
    case "A":
        mvparam.IC = 1;
        mvparam.SP = { ButtonMask=(1<<0), CheckFrameID=100, EndFrameID=101, SetPattern="214A_End" };
        break;
    case "B":
        mvparam.IC = 1;
        mvparam.SP = { ButtonMask=(1<<1), CheckFrameID=100, EndFrameID=101, SetPattern="214B_End" };
        break;
    case "C":
        break;
    case "EX":
        break;
    }

    ret_tmpl.FrameUpdate_After <- function() : (mvparam)
    {
        if(mvparam.IC) Battle_Std.SetPattern_NotHoldButton( mvparam.SP );
    }

    ret_tmpl.HitInterrupt_After <- function()
    {
        if( Battle_Std.CheckDamageTiming() )
        {
            Battle_Std.SetPosition_DamageHanteiRect( { power=100 } );
        }
    }

    return ret_tmpl;
}

t.Mv_Skill_214A <- maketmpl_WristStaccato( { type="A" } );
t.Mv_Skill_214B <- maketmpl_WristStaccato( { type="B" } );
t.Mv_Skill_214C <- maketmpl_WristStaccato( { type="C" } );
t.Mv_Skill_63214EX <- maketmpl_WristStaccato( { type="EX" } );

//-----------------------------------------------------------------------------
// Wrist Mordent - B+C/FF
//-----------------------------------------------------------------------------

// So... Get this... you can charge it TWICE.
// Uses confusing parry code that cancels projectiles and allows cancelling right after.
t.Mv_Atk_StdBandC <-
{
    function Init_After()
    {
        BMvTbl.SetLP(9,0); // Common initialization offset init
        Battle_Std.Sousai.Init( 0 ); // invul startup??????
        // BMvTbl.SetLP(4,0); // Reinforced shield
        BMvTbl.SetLP(2,0); // This LP is a switch for projectile counter
        Battle_Std.MoveCode.AddFlag( def_MC_Sousai|def_MC_Sousai_NoSubHitCount ); // Projectile Cancellation Occurs
    }
    function FrameUpdate_After()
    {
        Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<1)|(1<<2), CheckFrameID=100, EndFrameID=110, SetPattern="B+C_End", flags=Def_JFIDNHB_CheckAllButton } ); // Increase 1 - flags=Def_JFIDNHB_HoldForever JumpFrameIDxxx???
        Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<1)|(1<<2), CheckFrameID=200, EndFrameID=210, SetPattern="B+C_Ender", flags=Def_JFIDNHB_CheckAllButton } ); // Increase 2

        Battle_Std.Sousai.FrameUpdate( 10 ); // Invincibility time?

        Battle_Std.CheckSousai(); // Cancellable if sousai
        if( BMvTbl.GetLP(2)==0 && Battle_Std.MoveCode.CheckFlag( def_MC_Sousai_EnemySubSuccess ) ) // Check for projectile?
        {
            BMvTbl.SetLP(2,1); // The projectile was countered

            Battle_Std.GRD_AddValue( { val=10000, boundplus=1 } ); // GRD reward
            // BMvEff.AttackInfoString_Set({ word = "Cancelable" });
            BMvTbl.SetAsStatusFlag( { special=_CancelFlag_Always, time=254, flag=_ClearFlag_ChangeMv } ); // Enables cancelling?

            // 181120 If you cancel a projectile, you will be invincible for a while.
            // Even if you cancel the first part of Seth's 236EX, you may not be able to avoid the rest.
            BMvTbl.SetHitCheckFlag( { type=0, val=_HitCheckFlag_FireBall, time=254, flag=_ClearFlag_ChangeMv } ); // Fireball Invincibility
        }

        // Without this, you may fail to cancel out the shots.
        // Once you've canceled out the shots once, don't use it again. Without this, multiple shots will slip through strangely.
        if( BMvTbl.GetLP(2)==0 )
        {
                // If Param1(_paramno) is 8(_num), set head invincibility(_flag)
                // Set with FrameUpdate
                // Change to Flag format
                // 8: Head　_HitCheckFlag_Head　※It can also be a bullet lol
                // 16: Bullet　_HitCheckFlag_FireBall
                // 32: Leg　_HitCheckFlag_Legs
                // 64: Air Dive　Def_HitCheckFlag_AirDive
                // [_HitCheckFlag_Head] = "Air attack";
                // [_HitCheckFlag_Legs] = "Down attack";
                // [_HitCheckFlag_FireBall] = "Projectile";
                // [_HitCheckFlag_Legs|_HitCheckFlag_FireBall] = "Projectile & Down Attack";
                // [_HitCheckFlag_Legs|_HitCheckFlag_Head] = "Air Attack & Down Attack";
                // [_HitCheckFlag_Head|_HitCheckFlag_FireBall] = "Air Attack & Projectile";

                // TF this sets Param1 to Head Invincibility
            Battle_Std.SetHitMuteki( 1, 8, _HitCheckFlag_Head|_HitCheckFlag_Legs|_HitCheckFlag_FireBall ); // Param1 & 8: Bullet invincibility (changed to 16 as test)
        }
    }
    function HitInterrupt_After() // Successful Hit
    {
        local mvs = BMvTbl.GetMvStatus();
        local mvhs = Battle_Std.Sousai.HitInterrupt( { pride = def_MC1_AtkLow, noeffect=1 } );
        if( mvhs )
        {
            // BMvEff.AttackInfoString_Set({ word = "TRIGGER!!!" });
            if( mvhs.isFirstUpdate )
            {
                // If the counterattack hits, the opponent will be stunned.
                // Projectiles will also stun the opponent.

                // BMvTbl.SetLP(0,1);
                local eff = BMvEff.CreateObject( { start_pat="eff_WagSousai", y=-200<<7 } ); // I wanted to add cool wagner heavy hitstop stuff but i need to... TODO
                if( eff.push() )
                {
                    BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
                    eff.pop();
                }
            }
        }
    }
};

// 0202EX does not require code.

//-----------------------------------------------------------------------------
// Air Dodge - J B+C
//-----------------------------------------------------------------------------

t.Mv_Atk_AirBandC <-
{
    function Init_After()
    {
        BMvEff.SetCharaFlash( { color = 0x444444, time = 16 } ); // White flash
    }
    function FrameUpdate_After()
    {
         BMvTbl.SetMuki(_Direction_Auto ); // Face Proper Direction
    }
}

//-----------------------------------------------------------------------------
// IW - Official Apocrypha
//-----------------------------------------------------------------------------

t.Mv_Skill_41236SP <-
{
    function Init_After()
    {
        BMvEff.Chara_SetMessage( 640, 600, "Code... Ictus!", 120 );
    }
    function HitInterrupt_After()
    {
        if( Battle_Std.CheckDamageTiming() ) //Still dunno what this does *exactly*
        {
            Battle_Std.SetKezurareDamage( 50 );
            if( Battle_Std.CheckDamageTiming() )
            {
                Battle_Std.SetPosition_DamageHanteiRect( { power=100 } );
            }
            BMvTbl.SetNextMoveTable( "Mv_Skill_41236SP_Hit" );
        }
    }
    function Finalize_After()
    {
        Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Skill_41236SP_Hit"]);
    }
}

t.Mv_Skill_41236SP_Hit <-
{
    function Init_After()
    {
        BMvEff.FadeProc_Set({type=0, time=[0,10,30] color=0xFFFFFF});
        BMvEff.SetCamera_Clipping( 0 ); // Disable stage bounds for teh immmersion
        BMvEff.ThrowParam( { pattern=320, x=200, y=0, } );
        BMvEff.ThrowRelease( { type="追撃ダウン", airrecover=0, flags=0 } ); //開放のみ
    }
    function HitInterrupt_After()
    {
        if( Battle_Std.CheckDamageTiming() ) //Still dunno what this does
        {
            Battle_Std.SetPosition_DamageHanteiRect({ power=100 });
        }
    }
    function FrameUpdate_After()
    {
        switch( Battle_Std.GetUpdateFrameID() )
        {
        case 100:
            if ( Battle_Std.CheckEnemyisDamage() )
            {
                BMvEff.Chara_SetMessage( 640, 600, "Break through!", 75 );
            }
            break;
        case 205:
            Battle_Std.MoveCodeEx.AddFlag( 1, def_MC1_ChainShiftOK );
            break;
        }
        local s = BMvTbl.GetMvStatus(); // wtf
        switch( s.FrameID )
        {
        case 205:

            if( s.isFrameUpdate ) Battle_Std.FinalizeWorthSkill(); //終了
            break;
        }
    }
    function Finalize_After()
    {
        BMvEff.SetCamera_Clipping( 1 ); // So the wall is back on the edge
    }
}

//-----------------------------------------------------------------------------
// IWEX - Original Sin Embrace - TODO
//-----------------------------------------------------------------------------

t.Mv_Skill_IWEXIST <-
{
    //BMvEff.Chara_SetMessage( 640, 600, "Ictus...", 120, 600 );
    flags = def_TmplFlags_NoAddComboRate // Don't add to combo
    function HitInterrupt_After()
    {
        Battle_Std.SetThrowHitFinalize(256);
    }
    function Finalize()
    {
        //local btl = BMvTbl.CBtlInfo();
        local round = BMvTbl.GetMvRoundStatus();
        local training = BMvTbl.GetMvStageStatus().IsTrainingBattle() // Check if we're in training mode (1)
        local enemy = BMvCore.GetNearEnemyCharaData(); // For grabs?

            if( enemy.isdone ) // When obtained
            {
                BMvCore.PushCharaData( enemy ); // Fetch enemy data
                local hp_ratio = BCMDTbl.GetHPRatio();
                BMvCore.PopCharaData(); // Discard enemy data
                //BMvEff.AttackInfoString_Set({ word = hp_ratio });
                //BMvEff.AttackInfoString_Set({ word = btl.GetFixStageBGM() }); // this is for what character bgm is supposed to be for auto
                // TODO check currently playing bgm
                if ( ( round.Round >= 2 || training == 1 ) && hp_ratio <= 25 ) // Check round/training and enemy HP for KO threshold
                {
                    BMvEff.BGM_Set( { num = 65 } ); // Set anime music
                }
            }
        Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_IWEXIST_Hit"]);
    }
}

t.Mv_Skill_IWEXIST_Hit <-
{
    flags = def_TmplFlags_NoAddComboRate

    function Init_After()
    {
        Battle_Std.InitIWExistSkill();
        BMvEff.ThrowChara_SetJoint( 0 ); // Don't attach grabs?
        BMvEff.ThrowParam( { pattern=304, x=600, y=0, } );
        //BMvTbl.SetLP(0,0); // wtf?
        // BMvEff.Chara_SetMessage( 640, 600, "Code... Ictus!!", 240, 600 );
        BMvEff.Chara_SetMessage( 640, 600, "Pray!", 240, 612 );
        local epos = Battle_Std.GetEnemyPosition();
        // BMvEff.SetCamera_Focus( { num=1, x=epos.x - (340<<7)*BMvTbl.GetMuki(), y=0, zoom=0.9, time=[0,00,30], type_in=0 } );
        BMvEff.SetCamera_Focus( { num=0, x=epos.x - (340<<7)*BMvTbl.GetMuki(), y=0, zoom=0.9, time=[0,50,30], type_out=1 } );

    }

    function FrameUpdate_After()
    {
        switch( Battle_Std.GetUpdateFrameID() )
        {
        case 100: // Hit
            //BMvEff.ThrowParam( { x=125, y=0, pattern=320 } );
            BMvEff.SetCamera_Quake( { time=60, type=0, clear=0, } ); //揺らし
            BMvEff.Slowmotion_Set( { time=60, power=5000 } );
            BMvEff.FadeProc_Set({type=0, time=[0,10,30] color=0xFFFFFF});
            break;
        case 120:
                    BMvEff.FadeProc_Set({type=0, time=[1,100,30] color=0xFFFFFF});
            BMvEff.Cockpit_SetView( { mode=2 } ); // 一部のみ消去
            BSound.BGM_SetFade( { val=50, time=90 } );//BGMのフェードアウト
            //白フェードでイン
            //BMvEff.FadeProc_SetRenderFlag(0); //Hide the IWEX bg
            BMvEff.FadeProc_SetRenderFlag(0); // 0:カットインBG描画なし
            //Battle_Std.ScreenEffect_LimitPat( { y=64*128, pat="LABG" } );
            local enemy = BMvCore.GetNearEnemyCharaData();
            if( enemy.push() )
            {

                BMvTbl.SetVector( { x = -28, y = -64,  flags=_Vector_Bound } );
                // BMvTbl.SetPosition( { x=200, y=-10000 } );
                BMvEff.SetCharaFlash( { color = 0x000000, type = 0, time = 10 } );
                BMvEff.SetCharaColor( { color = 0x000000, type = 0, intime = 60, time = 60 } );
                enemy.pop();
            }
            BMvEff.Chara_SetMessage( 640, 590, "Should thy soul bear any miracle, thou shalt be saved in the wake of judgment!!", 1000, 613 ); // x y string delay se_optinoal
            BMvTbl.SetPosition( { x=-500 } );
            break;
        case 200:

            local enemy = BMvCore.GetNearEnemyCharaData();
            if( enemy.push() )
            {
                BMvTbl.SetPosition( { x=200, y=-10000 } );
                enemy.pop();
            }
            break;
        case 250:
            local enemy = BMvCore.GetNearEnemyCharaData();
            if( enemy.push() )
            {
                BMvTbl.SetPosition( { x=200, y=-10000 } );
                BMvTbl.SetSpPrio( { prio=1 } );

                enemy.pop();
            }
            //BMvTbl.SetVector( { x=-1000, addx=10, y=0, flags=_Vector_Normal } );
            //BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Set } ); //?J???‰?c?c?O?e?£?・
            BMvTbl.SetVector( { x=-100, y=0 } );
            //BMvEff.SetCamera_Focus( { num=0, x=epos.x - (340<<7)*BMvTbl.GetMuki(), y=0, zoom=0.9, time=[0,50,30], type_out=1 } );
            BMvEff.ThrowParam( { x=350, pattern = 320, frame = 0 } );
            local epos = Battle_Std.GetEnemyPosition();
            BMvEff.SetCamera_Focus( { num=0, y=-100*128, x=epos.x-200*128, zoom=4.0, time=[0,999,30] } );
            BMvEff.SetCamera_Focus( { num=1, y=-64, x=epos.x-180*128, zoom=1.3, time=[160,999,30], type_in=1 } );
            // BMvEff.SetCamera_Focus( { num=1, zoom=1.2, time=[90,255,120], type_out=2 } );
            //?z???C?g?C?“
            BMvEff.FadeProc_Set( { type=0, time=[ 0, 1, 10 ], color = 0xFFFFFF } );

            break;

        case 310:
            // shield = Battle_Std.CreateObjectEX( { x=-25, y=-300, datatype=0, pat=983, flags=_Position_ToolShift } );
            BMvEff.CreateObject({ mvname="Mv_Obj_Eff_Shld" });
            break;
        case 350:
            local expl3 = Battle_Std.CreateObjectEX( { datatype=0, pat=987, flags=_Position_ToolShift } );
            if( expl3.push() )
            {
                Battle_Std.SetPos_MarkingEnemy();
                BMvTbl.SetSpPrio( { prio=2 } );
                BMvTbl.SetPosition( { x=50, flags=_Position_CaptureShift|_Position_Add } )

                expl3.pop();
            }
            break;
        case 500:
            BMvEff.SetCamera_Focus( { num=0, time=[0,999,30] } );
            BMvEff.SetCamera_Focus( { num=1, y=0, zoom=1.0, time=[25,999,30], type_in=3 } ); //0 Linear 1 Fast in 2 Slow in 3 Fast middle 4 slow to fast
            break;
        case 600:
            local enemy = BMvCore.GetNearEnemyCharaData();
            if( enemy.push() )
            {
                Battle_Std.CreateObjectEX( { y = 26000, angle=2500, datatype=1, pat=30, flags=256 } );
                BMvTbl.SetVector( { x=-1400, y=-1400, addx = 40, addy = 30,  flags=_Vector_Bound } );
                // BMvTbl.SetPosition( { x=200, y=-10000 } );
                enemy.pop();
            }
            break;
        case 610:
            local eff = Battle_Std.CreateObjectEX( { x=-450, y = -100, angle=2000, datatype=0, pat=973, flags=_Position_ToolShift } );
            if( eff.push() )
            {
                eff.pop();
            }
            break;
        case 620:
            local enemy = BMvCore.GetNearEnemyCharaData();
            BMvEff.Slowmotion_Set( { time=60, power=5000 } );
            if( enemy.push() )
            {
                Battle_Std.InitVector();
                // BMvTbl.SetPosition( { x=200, y=-10000 } );
                enemy.pop();
            }
            local LABG = Battle_Std.ScreenEffect( { pat="LABG" } );
            if( LABG.push() )
            {
                //BMvTbl.SetMuki( _Direction_Right );
                LABG.pop();
            }
            if( expl.push() )
            {
                Battle_Std.SetPos_MarkingEnemy();
                BMvTbl.SetSpPrio( { prio=2 } );
                BMvTbl.SetPosition( { x=200, y=-100, flags=_Position_CaptureShift|_Position_Add } )
                expl.pop();
            }
            local expl = Battle_Std.CreateObjectEX( { datatype=0, pat=985, flags=_Position_ToolShift } );
            if( expl.push() )
            {
                Battle_Std.SetPos_MarkingEnemy();
                BMvTbl.SetSpPrio( { prio=2 } );
                BMvTbl.SetPosition( { x=200, y=-100, flags=_Position_CaptureShift|_Position_Add } )
                expl.pop();
            }
            local expl2 = Battle_Std.CreateObjectEX( { datatype=0, pat=986, flags=_Position_ToolShift } );
            if( expl2.push() )
            {
                Battle_Std.SetPos_MarkingEnemy();
                BMvTbl.SetSpPrio( { prio=2 } );
                BMvTbl.SetPosition( { x=-100, y=-600, flags=_Position_CaptureShift|_Position_Add } )
                expl2.pop();
            }
            local expl3 = Battle_Std.CreateObjectEX( { datatype=0, pat=987, flags=_Position_ToolShift } );
            if( expl3.push() )
            {
                Battle_Std.SetPos_MarkingEnemy();
                BMvTbl.SetSpPrio( { prio=2 } );
                BMvTbl.SetPosition( { x=50, flags=_Position_CaptureShift|_Position_Add } )

                expl3.pop();
            }
            break;
        case 777:
            BMvEff.ThrowRelease( { type="頭やられ弱", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
            BMvEff.Chara_SetMessage( 640, 600, "Calvariat... SEAL!!", 120, 611 );
            BMvEff.FadeProc_Set({type=0, time=[0,1,30] color=0xFFFFFF})
            break;
        }
    }
    function LastUpdate_After()
    {
        BMvEff.FadeProc_SetRenderFlag(0); // 0:カットインBG描画なし
        BMvEff.SetCamera_Quake( { time=0, type=2, clear=0, } ); //揺らし
        Battle_Std.FinalizeIWExistSkill();
        BMvEff.SetCamera_Clipping( 1 ); //‰a?E’[?I?N???b?s?“?O?a?3?d?s?・
        BMvEff.SetCamera_Focus( { time=[0,0,30] } ); // ?J???‰?A’e?d?s?・
        BMvEff.SetCamera_Quake( { time=0, type=2, clear=0, } ); //?h?c?μ
        BMvEff.SetCamera_FocusKeep( 0 );
        BMvEff.ResetCamera(); //?J???‰?‰?u‰≫
        BMvEff.ResetViewCamera();
    }
}

t.Mv_Skill_IWEXIST_Hit2 <-
{
    function Init_After()
    {
        BMvEff.SetCamera_Focus( { charapos=0, zoom=10.25, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } );
        BMvTbl.SetPosition( { x=0, } );
        BMvEff.AttackInfoString_Set({ word=def_AISW_Invincibility,} );
    }
    function LastUpdate_After() //
    {
        BMvEff.FadeProc_SetRenderFlag(1); // 0:カットインBG描画なし
        BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Erase  } ); //カメラから切り離す
        BMvEff.SetCamera_Focus( { time=[0,0,30] } );
        BMvEff.ResetCamera(); //カメラ初期化
        BMvEff.ResetViewCamera();
        local p = BMvCore.GetCaptureCharaData();
        if( p.IsDone )
        {
            BMvCore.PushCharaData( p ); //
                BMvEff.EraseObjectFlags( { flags=_ObjFlags_NoRender } ); //非表示にする
                BMvEff.SetExist( { level=_Exist_NoCamera, mode=_ExistMode_Erase  } ); //カメラから切り離す
                BMvEff.SetCharaDrawType( { type=0 } );
                BMvEff.SetCharaColor( { time=0 } );
            BMvCore.PopCharaData(); //
        }
        BMvEff.SetExist( { level = 0 } );
        BMvEff.FadeProc_Erase( { type=1 } );
        BMvEff.FadeProc_Erase( { type=0 } );
        BMvEff.SetCharaDrawType( { type=0 } );
        BMvEff.SetCharaColor( { time=0 } );
        BMvTbl.SetLP( 1, 255 ); //花びらに終了を伝える
        //Battle_Std.FinalizeIWExistSkill();
    }
    function Finalize() //
    {
        BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST_End" );
    }
}

t.Mv_Skill_IWEXIST_End <- {
    function Init_After()
    {
        BMvEff.ThrowChara_SetJoint( 0 ); // Don't attach grabs?
        BMvEff.ThrowParam( { pattern=304, x=600, y=0, } );
    }
};

//-----------------------------------------------------------------------------
// Beast Mode Easter Egg
//-----------------------------------------------------------------------------

Install.Timer <- function()
{
    local timeLeft = BMvTbl.GetPP(InstallTimer);
    BMvEff.AttackInfoString_Set({ word = timeLeft });
}


t.Mv_Skill_020202EX <- // Uses rotation input. Main Install mv
{
    function Init_After()
    {
        BMvEff.SetCamera_Quake( { time=100, type=2, clear=0, } );
        BMvEff.Liberate_SetMinusValue( 9999 ); // This burns VO gauge entirely
    }
    function FrameUpdate_After()
    {
        switch( Battle_Std.GetUpdateFrameID() )
        {
        case 10:
            BSound.BGM_SetFade( { val=0, time=30 } ); // Tune out th emusic
            break;
        case 15:
            BMvEff.FadeProc_Set({type=0, time=[0,5,10] color=0xFFFFFF});
            BMvEff.PcAuraEffect_Set( { type=0, time=2000, power=3.2, color=0x555555FF, colorB=0x88FF4444, color_chara=0x001F0505, blendmode=1, delay=120 } );
            BMvEff.Slowmotion_Set( { time=75, power=9999 } );
            BMvEff.SetCamera_Focus( { charapos=1, zoom=1.25, time=[30,def_FL_SPCutinStopTime-40,10], type_in=3, type_out=1 } );
            //BMvEff.SetStopTime({ time=10, });
            Battle_Std.CreateTechObject_TechMissStart();
            Battle_Std.SetCharaFlash_Counter();
            local breaktime = def_GRDBF_NormalAtkDmg;
            BMvEff.GRD_SetBreak( 0, breaktime, breaktime ); // GRD break
            BMvTbl.SetPP(Installed, InstallTimer); // Set a bunch of variables
            BMvTbl.SetPP(CDef_Rie_PP_DragonInstall, 1);
            BMvTbl.SetPP(CDef_Rie_PP_InstallLimit, 1);
            BMvTbl.SetPP(CDef_Rie_PP_InstallTimer, 999); // Lasts 999 frames
            break;
        case 20:
            BMvEff.BGM_Set( { num = 191 } ); // BLOOD HEAT BGM
            break;
        case 40:
            BMvEff.AttackInfoString_Set({ word=def_AISW_Invincibility,} );
            break;
        case 150:
            BMvEff.Slowmotion_Set( { time=60, power=7000 } );
            Battle_Std.ComboPoint_Multi( 300 );
            BMvTbl.ComboPoint_Calc( { num=1000 } );
            local enemy = BMvCore.GetEnemyCharaData();
            if( enemy.push() )
            {
                BMvEff.SetBoundSt( { addtime = 300 } ); // のけぞり増加
                enemy.pop();
            }
			BMvTbl.SetLP(10,1);
            BMvEff.CreateObject( { mvname="Mv_Obj_BeastMode" } );
            break;
        }
    }
    function LastUpdate_After()
    {
        BSound.BGM_SetFade( { val=100, time=4 } );
    }
}

t.DamageImpact <- function(info) : (chrFunc)
{
    if ( BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) == 1 )
    {
        BMvEff.SetCharaFlash( { color = 0xFF50FF, type = 0, time = 10 } );
        BMvEff.SetCharaColor( { color = 0x0000FF, type = 0, intime = 60, time = 90 } );
        BMvTbl.SetPP(CDef_Rie_PP_InstallTimer, -1);
    }
}

//t.GeneralInterrupt
t.AttackImpact <- function(info) : (chrFunc) // Called whenever the enemy is attacked in any way
{

    Battle_Std.AttackImpact_StdFunc(info);
    local Guard = ((info.flags&_ImpactFlag_IsGuard)!=0);
    local Nage = (info.atk_throw!=0); //投げ判定かどうか
    local Yarare = (((info.flags&_ImpactFlag_IsBound)!=0)&&!Guard);
    local Capture = (((info.flags&_ImpactFlag_IsCapture)!=0 ) && !Guard );
    local Nage_Shodan = (!Capture &&Nage); // 投げのみ ※投げ初段で処理をすると、通常投げの投げ抜け待機とかも反応するよ
    local Syodan = (!Yarare); // 打撃
    local Zenbu_Shodan = (Syodan || Nage_Shodan); // 打撃でも投げで
    //BMvEff.AttackInfoString_Set({ word = Guard });

    if ( BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) == 1 )
    {
        BMvEff.CreateObject( { mvname="Mv_Obj_BeastModeOnHit" } );
        local enemy = BMvCore.GetNearEnemyCharaData();
        if ( enemy.push() )
        {
            if(Guard)
            {
                Battle_Std.SetKezurareDamage( 50 );
            }
            BMvEff.SetCharaFlash( { color = 0xFF0000, type = 2, time = 10 } );
            BMvEff.SetCharaColor( { color = 0xFF0000, type = 0, intime = 5, time = 40 } );
            enemy.pop()
        }
        //BMvTbl.SetFinalize();
        BMvTbl.SetAsStatusFlag( { normal=_CancelFlag_Always, special=_CancelFlag_Always, time=254, flag =_ClearFlag_ChangeFrame|_ClearFlag_ChangePattern|_ClearFlag_ChangeMv } )
        //Battle_Std.MoveCode.AddFlag(def_MC_EnableCansel_SkilltoSkill); // Way too busted
        //Battle_Std.MoveCode.AddFlag(def_MC_EnableCansel_SkilltoAtk); // I'd allow this if EX moves weren't included
        Battle_Std.MoveCode.AddFlag(def_MC_EnableCansel_SkilltoJump); // That's all I can do
        Battle_Std.GRD_AddValue( { val=-150 } );
        //BMvTbl.SetFinalizeCode(0);
    }
    else
    {

    }

    local mvs = BMvTbl.GetMvStatus();
    local ret_frameid = mvs.FrameID;

    //BMvEff.AttackInfoString_Set({ word = BMvTbl.GetPP(CDef_Rie_PP_DragonInstall) });
    //BMvEff.AttackInfoString_Set({ word = BMvTbl.GetMvStatus().MvCountFrame });

}

t.Mv_Obj_BeastModeOnHit <-
{
    function Init_After()
    {
        //Battle_Std.ComboPoint_Multi(150);
        local enemy = BMvCore.GetEnemyCharaData();
        if( enemy.push() )
        {
            BMvEff.SetBoundSt( { addtime = 8 } );
            //BMvTbl.SetLP(6,1000);
            enemy.pop();
        }
        local player = BMvCore.GetPlayerCharaData();
        if (player.push() )
        {
            Battle_Std.MoveCode.AddFlag(def_MC_EnableCansel_SkilltoJump);
            player.pop();
        }
    }
}

t.Mv_Obj_BeastMode <- // TODO This is the visual timer, time to make it into a real gauge
{
    function Init_After()
    {
    //  Battle_Std.CreateObjectEX( { y = 24000, datatype=1, pat=973} );
    }
    function FrameUpdate_After()
    {
        Battle_Std.SetPos_MarkingPlayer();
        local s = BMvTbl.GetMvStatus();

        if( s.FrameID==10 )
        {
            Battle_Std.CreateObjectEX( { y = 26000, angle=2500, datatype=1, pat=31, flags=_Position_ToolShift } );
            Battle_Std.CreateObjectEX( { y = 24000, angle=-2500, datatype=1, pat=31, flags=_Position_ToolShift } );
        }
        Battle_Std.CreateObjectEX( { y = 26000, angle=2500, datatype=1, pat=30 } );
        Battle_Std.CreateObjectEX( { y = 24000, angle=-2500, datatype=1, pat=30} );

        BMvTbl.AddPP(CDef_Rie_PP_InstallTimer, -1);
        BMvTbl.SetScale({ x=(100*BMvTbl.GetPP(CDef_Rie_PP_InstallTimer)) });
        // BMvEff.AttackInfoString_Set({ word = BMvTbl.GetPP(CDef_Rie_PP_InstallTimer) });

        if ( BMvTbl.GetPP(CDef_Rie_PP_InstallTimer) <= 0 )
        {
            local player = BMvCore.GetPlayerCharaData();
            if( player.push() )
            {
                local movable = BCMDTbl.CheckCancel( _SkillType_None );
                if( movable )
                {

                    //local player = BMvCore.GetPlayerCharaData();
                    player.pop()

                    BMvTbl.JumpFrameID( 100 );
                    BMvTbl.SetPP(CDef_Rie_PP_DragonInstall, 0);
                    BMvTbl.SetFinalize();
                }
            }
        }
    }
    function Finalize()
    {
        local player = BMvCore.GetPlayerCharaData();
        local og = BMvTbl.CBtlInfo.GetSelectBgm();
        BMvEff.BGM_Set( { num = og } );
        BMvEff.AttackInfoString_Set({ word = og });
        if (player.push() )
        {
			BMvTbl.SetLP(10,0);
            Battle_Std.MoveCodeEx.DelFlag(6, def_MC6_EnableCansel_JumpMoveable);
            Battle_Std.MoveCode.DelFlag( def_MC_EnableCansel_SkilltoSkill);
            Battle_Std.MoveCode.DelFlag( def_MC_EnableCansel_SkilltoAtk);
            Battle_Std.MoveCode.DelFlag( def_MC_EnableCansel_SkilltoJump);
            BMvTbl.SetPattern(992);
            //BMvTbl.SetNextMoveTable(Mv_BeastMode_End);
            BMvEff.SetCharaFlash( { color = 0xFF50FF, type = 0, time = 10 } );
            BMvEff.SetCharaColor( { color = 0x0000FF, type = 0, intime = 60, time = 90 } );
            player.pop();
        }
    }
}

t.Mv_BeastMode_End <-
{
    function Init_After()
    {
        BMvTbl.SetMoveableFlag( { move=0, time=254 } );
    }
    function FrameUpdate_After()
    {
        Battle_Std.MoveCodeEx.DelFlag(6, def_MC6_EnableCansel_JumpMoveable);

        local player = BMvCore.GetPlayerCharaData();
        if( player.push() )
        {
            local isGround = BMvTbl.CheckPosState( _PosState_Ground );
            local pos = BMvTbl.GetPosition(0);
            if( isGround )
            {
                Battle_Std.MoveCodeEx.DelFlag(6, def_MC6_EnableCansel_JumpMoveable);

            }
            player.pop();
        }
    }

}

// t.Mv_Liberate <-
// {
    // function Init_After()
    // {
       // BMvEff.SetBgSpeculer( { color=0x888888 } );
       // BMvEff.SetBgColor( { color=0x808080 } ); // Filter rgb
    // }
// }

// t.Mv_Skill_0202D <-
// {
    // function Finalize_After()
    // {
        // BMvEff.Cockpit_SetView( { mode=0 } );
    // }
// }

//-----------------------------------------------------------------------------
// Finish
//-----------------------------------------------------------------------------

RIES_MoveTable <- Battle_Std.MakeMoveTable( t, RIES_CommandTable, Def_ChrNo_Rie );
__dofile__("./data/Ries/Ries_se_category.txt");