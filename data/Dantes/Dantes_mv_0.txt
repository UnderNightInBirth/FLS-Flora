local t = {}; // Collects all the move data


local t = {};

//-----------------------------------------------------------------------------
// 固有関数
//-----------------------------------------------------------------------------

t.Mv_Null_BattleMain <-
{
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll|_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_ParentMuki } );
		BMvTbl.SetPrio( _CharaPrio_Parent_M1 ); // プレイヤー基準で「親-1」
	}
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		local mvcount = mvs.MvCount;

		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local obj_norender = BMvEff.CheckObjectFlags( { flags=_ObjFlags_NoRender } );//描画なしのとき
			
			local palpha = BMvTbl.GetDrawAlpha();
			local pmvs = BMvTbl.GetMvStatus();
			local pst_cro = BCMDTbl.CheckPosState(_PosState_Crouch );
			local pmvname = BMvTbl.GetMvName();
			
			// PAT920のときは表示位置が少しズレているので特殊な位置補正をかける
			local ex_xpos_hosei = (pmvs.DataPattern == 920)? 1 : 0;

			local is_downgrp_mv = ( pmvname == "Mv_RoundLose" || pmvname == "Mv_Lose" ); // BoundStatus.IsDownで検知できない倒れている絵
			local is_downgrp_pat = ( pmvs.DataPattern >= 648 && pmvs.DataPattern <= 662 );
			
			local bs = BtlMvStd.GetBoundStatus();
			local pst_down = (bs.isBound && bs.IsDown() || is_downgrp_mv || is_downgrp_pat )? 1 : 0;
			
			if( mvcount % 16 == 0 && !obj_norender )
			{
				local pos = { x=0, y=-200*128 }; // 呼び出す座標
				
				if( ex_xpos_hosei ) // 絵の座標がズレているもの
				{
					pos.x = -80*128;
				}
				
				// 円形のランダムで呼び出す
				// しゃがみとダウンのときは範囲を変える
				// KO後はダウン状態じゃないのでisKOを見る
				local rnd_circle = { x=100*128, y=40*128 };
				if( pst_cro )
				{
					pos.y = -80*128;
					rnd_circle.y = 30*128;
				}
				else if( pst_down )
				{
					pos.y = 0*128;
					rnd_circle.x = 200*128;
					rnd_circle.y = 10*128;
				}
				
				// 呼び出し先決定
				local rnd_pos = BMvEff.Random_PointRad( { radx=rnd_circle.x, rady=rnd_circle.y } );
				pos.x += rnd_pos.x;
				pos.y += rnd_pos.y;

				// パターンをランダム決定
				local pat = 160 + BMvEff.Random_Limit(2);

				local eff = BMvEff.CreateObject( { start_pat=pat, x=pos.x, y=pos.y, mvname="Mv_BlackFrames" } );
			}
			player.pop();
		}
	}
}

t.Mv_BlackFrames <-
{
	function Init()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_ParentMove|_ObjFlags_NoRenderBlackOut|_ObjFlags_NoRenderOrder } );
	}
	function Update()
	{
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local obj_norender = BMvEff.CheckObjectFlags( { flags=_ObjFlags_NoRender } );//描画なしのとき
			local palpha = BMvTbl.GetDrawAlpha();
			
			player.pop();
			
			// _dpn("palpha:"+palpha);
			
			if( obj_norender )
			{
				BMvTbl.SetFinalize();
			}
			if( palpha ) BMvTbl.SetDrawAlpha( { val=palpha, time=2, flag=0 } );
		}
	}
	function Finalize()
	{
		BMvTbl.SetDeleteMoveTable();
	}
}

// 毒炎ダメージ
// 削りダメージは100ぐらいのドットダメージ
// ドットダメージ中に再度受けると、5回まで効果は重複するが、補正がかかって減らなくなる（1回のガードorコンボで最大200ダメージ）
// ドットダメージの速度は、予定されている総ダメージまでの残りで決まる
// コンボダメージに加算されるイメージでいうとかなり強い計算になる
t.Mv_Null_BlackFireDotDamage <-
{
	function Init_After()
	{
		BMvTbl.SetLP(0,0);

		BMvTbl.SetLP(1,0); // 1:終了予約

		BMvTbl.SetLP(2,0); // 1:加算予約

		BMvTbl.SetLP(7,0); // 1:シールドによる強制終了

		BMvTbl.SetLP(8,1); // 何回呼ばれたかのカウンタ 1:初回 2:2回目...
		BMvTbl.SetLP(9,100); // 削り予定量
		
		// local uniq_id = BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } );
		// _dpn("行動変わってないですよね？:"+uniq_id);
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local shielded = Battle_Std.MoveCode.CheckFlag( def_MC_Shielded );
			
			if( !shielded )
			{
				// _dpn("加算済みなのを記憶");
				Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag1 );
			}
			player.pop();
			
			if( shielded )
			{
				BMvTbl.SetFinalize();

				// この処理にするorUpdateをFrameUpdateにするかのどっちか
				BMvTbl.SetLP(7,1); // 1:シールドによる強制終了
				return;
			}
		}
	}
	function Update_After()
	{
		// KO後やシールドされて入ったときは即終わる
		// 巌窟王の被弾でも終わる
		if( BMvEff.IsKoFinishType() || BMvTbl.GetLP(7)==1 || Battle_Std.CheckPlayerisDamage() )
		{
			BMvTbl.SetFinalize();
			return;
		}
		
		// ドットダメージ中に再度攻撃がきたとき、ドットダメージの総量を増やす処理
		// シールドされたときは増えないようにする
		if( BMvTbl.GetLP(2)==1 ) // 加算予約があった
		{
			BMvTbl.SetLP(2,0); // 加算予約処理を消す
			
			local do_process = 0;
			
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local shielded = Battle_Std.MoveCode.CheckFlag( def_MC_Shielded );
				local done_process = Battle_Std.MoveCode.CheckFlag( def_MC_CharaFlag1 );//処理済み
				
				do_process = ( !shielded && !done_process );

				// _dpn("shielded:"+shielded);
				// _dpn("done_process:"+do_process);
				
				// TODO:もうちょい処理を整理する…
				
				if( do_process )
				{
					Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag1 );//処理済み
				}
				
				player.pop();
				
				if( do_process )
				{
					local count = BMvTbl.AddLP(8,1);
					switch( count )
					{
					case 2: // 2
						BMvTbl.AddLP(9,40);//140
						break;
					case 3:
						BMvTbl.AddLP(9,30);//170
						break;
					case 4:
						BMvTbl.AddLP(9,20);//190
						break;
					case 5:
						BMvTbl.AddLP(9,10);//200
						break;
					}
				}
			}
		}

		local mvs = BMvTbl.GetMvStatus();
		
		// 終了予約が入った後は、相手のコンボやガードが解除されるまで生きる
		// 連続ガードや一連のコンボでめちゃくちゃ削られないため
		if( BMvTbl.GetLP(1)==1 )
		{
			if( !Battle_Std.CheckEnemyisBound() )
			{
				// _dpn("やられorガードが解除されたので終了");
				BMvTbl.SetFinalize();
				return;
			}
		}


		// 削り予定量が多いときは減らすスピードをアップする
		local sabun = BMvTbl.GetLP(9) - BMvTbl.GetLP(0);//あとどんだけ削る予定？
		local count_par = 3; // 何フレームに1回処理をするか
		local damage = 1;
		if( sabun > 80 ) // 上限は200
		{
			count_par = 1;
			damage = 4;
		}
		else if( sabun > 60 )
		{
			count_par = 1;
			damage = 3;
		}
		else if( sabun > 40 )
		{
			count_par = 1;
			damage = 2;
		}
		else if( sabun > 20 )
		{
			count_par = 1;
			damage = 1;
		}
		else if( sabun > 10 )
		{
			count_par = 2;
			damage = 1;
		}

		if( mvs.MvCount%count_par == 0 )
		{
			if( BMvTbl.GetLP(0) > BMvTbl.GetLP(9) ) // 予定量オーバー
			{
				// _dpn("終了予約");
				BMvTbl.SetLP(1,1); // 1:終了予約
				return;
			}
			else
			{
				BMvTbl.SetLP(1,0); // 1:終了予約を消す
				BMvTbl.AddLP(0,damage); // 与えたダメージカウンタ加算
				
				// _dpn("削り中...:"+(BMvTbl.GetLP(0)-1)+" / "+BMvTbl.GetLP(9)+" * "+BMvTbl.GetLP(8)+" dmg:"+damage );
				
				local enemy = BMvCore.GetEnemyCharaData();
				if( enemy.push() )
				{
					BMvEff.SetHpGauge( { value=-damage, valuetype=2 } );
					
					enemy.pop();
				}
			}
		}
	}
}

local set_blackfiredamage = function()
{
	// ヒットorガード
	// 攻撃判定同士の相殺は除外
	if( Battle_Std.CheckHitTiming() && !Battle_Std.CheckSousaiHitTiming() )
	{
		// 1つの行動で1回までにする
		if( Battle_Std.MoveCode.CheckFlag( def_MC_CharaFlag1 ) )
		{
			//処理済み
			return;
		}
		
		// 巌窟王は複雑な飛び道具がないので、playerをpushして処理すれば概ね大丈夫のはず
		local mychara = BMvCore.GetMyCharaData();
		local my_uniqid = BMvTbl.CheckMvUniqueID( { datatype=_DataType_Player } );
		
		local player = BMvCore.GetPlayerCharaData();
		if( player.push() )
		{
			local do_process = 1; // 処理をするかどうか
			
			if( !mychara.isPlayer() )
			{
				if( my_uniqid )
				{
					// _dpn("飛び道具で行動変化してない");
				}
				else
				{
					// _dpn("飛び道具で行動変化してる → 削りはナシ");
					do_process = 0; // 処理をするかどうか
				}
			}
			
			if( do_process )
			{
				local findchara = BMvCore.CFindObject().Get(9);
				if( findchara.push() )
				{
					// 予約タイプにしないとシールドされたときが検知できない
					BMvTbl.SetLP(2,1); // 1:加算予約
					// _dpn("加算予約");

					findchara.pop();
				}
				else
				{
					BMvEff.CreateObject( { mvname="Mv_Null_BlackFireDotDamage", id=9 } );
				}
			}
			player.pop();
		}
	}
}

t.Mv_AniSet_UpperUkase <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [334,0,5], },
	{ Data = [334,1,3], Vector={ x=0,y=-3200,addx=0,addy=150,flags=_Vector_Normal }, },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
	{ Data = [334,4,3], },
	{ Data = [334,1,3], },
	{ Data = [334,2,3], },
	{ Data = [334,3,3], },
	{ Data = [334,4,3], },
	{ Data = [334,5,5], },
	{ Data = [334,6,5], },
	{ Data = [334,7,5], },
	{ Data = [334,8,5], RelJump = 0 },
] } );

t.Mv_Throw_F_Hit <- 
{
	function Init_After()
	{
		// 無敵で相手をつかみ開放の初期設定
		Battle_Std.MutekiThrowRelease_Init();
	}
	function FrameUpdate_After()
	{
		// 無敵で相手を掴み開放
		Battle_Std.MutekiThrowRelease( { FrameID=100, x=220, y=0, type="無声ダウン" } );
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			// アッパー
			BMvEff.ThrowChara_SetJoint( 0 ); // 相手を切り離す
			BMvEff.CreateObject( { mvname="Mv_AniSet_UpperUkase" } );
			break;
		case 70:
			// 空中でつかむ
			Battle_Std.MakeMv.LastCharaAnimeEnd(1); // アニメ解除ベクトル初期化
			BMvEff.ThrowChara_SetJoint( 1 ); // 相手をくっつける
			break;
		case 100:
			// 開放・叩きつけ着地
			BMvEff.ThrowChara_SetJoint( 0 ); // 相手を切り離す
			break;
		}
	}
}

t.Mv_AniSet_AirThrowUkase <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [330,0,5], },
	{ Data = [330,1,5], Vector={ x=-1200,y=-1800,addx=0,addy=220,flags=_Vector_Normal }, },
	{ Data = [330,2,5], },
	{ Data = [330,3,5], },
	{ Data = [330,4,5], },
	{ Data = [330,5,5], RelJump = 0 },
] } );

t.Mv_Throw_A_Hit <- 
{
	function Init_After()
	{
		// 無敵で相手をつかみ開放の初期設定
		Battle_Std.MutekiThrowRelease_Init();
		
		BMvTbl.SetLP(0,0);//つかみのキャラ差がうまれなくなったら1
	}
	function FrameUpdate_After()
	{
		// 無敵で相手を掴み開放
		Battle_Std.MutekiThrowRelease( { FrameID=100, x=100, y=50, type="無声ダウン" } );
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			// 切りつけて浮かせる
			BMvEff.ThrowChara_SetJoint( 0 ); // 相手を切り離す
			BMvTbl.SetLP(0,1); // つかみのキャラ差消滅
			BMvEff.CreateObject( { mvname="Mv_AniSet_AirThrowUkase" } );
			break;
		case 100:
			// 開放・叩きつけ着地
			Battle_Std.MakeMv.LastCharaAnimeEnd(1); // アニメ解除ベクトル初期化
			break;
		}
		
		if( BMvTbl.GetLP(0)==1 ) // つかみのキャラ差がなくなったので中央シフトOK
		{
			BtlPl.SetPos_CaptureGamenHajiXHosei();//つかみ相手が画面外なら互いに中央にシフト
		}
	}
}


t.Mv_ComboLiberate <- 	//Veil Off Combo
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 40:
			BMvEff.CreateObject( { mvname="Mv_BloodCutin" } );
			break;
		}
	}
}

t.Mv_Liberate <- 	//Veil Off
{
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 40:
			BMvEff.CreateObject( { mvname="Mv_BloodCutin" } );
			break;
		}
	}
}

//-----------------------------------------------------------------------------
// 空中ダッシュ
//-----------------------------------------------------------------------------

t.Mv_MultiJump_F <- 
{
	function Init_After()
	{
		BMvTbl.SetMuki(_Direction_Auto );		
	}
}
t.Mv_MultiJump_N <- 
{
	function Init_After()
	{
		BMvTbl.SetMuki(_Direction_Auto );		
	}
}
t.Mv_MultiJump_B <- 
{
	function Init_After()
	{
		BMvTbl.SetMuki(_Direction_Auto );		
	}
}

t.Mv_Skill_J0202B <- 
{
	function Init_After()
	{
		BMvTbl.AddAirCount( 1, 1 ); // 空中で何度も出せないようにする
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AirAssult ); // 空中アサルト扱い
		
		Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag2 ); //エリアル属性を解除するMv
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			break;
		case 500:
			//行動可能にして先行入力を受け付ける
			BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
			break;
		}
	}
}

t.Mv_Skill_Melty_AirDash_F <-
{
	function Init_After()
	{
		BMvTbl.AddAirCount( 1, 1 ); // 空中で何度も出せないようにする
		Battle_Std.MoveCodeEx.AddFlag( 7, def_MC7_AirAssult ); // 空中アサルト扱い
		
		Battle_Std.MoveCode.AddFlag( def_MC_CharaFlag2 ); //エリアル属性を解除するMv
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			break;
		case 500:
			//行動可能にして先行入力を受け付ける
			BMvTbl.SetCommandLongDelay(2); //受付時間増加（先行入力用）
			break;
		}
	}
}

//-----------------------------------------------------------------------------
// イベント
//-----------------------------------------------------------------------------

t.Mv_Startup <-
{
	function Init_After()
	{
		BMvEff.CreateObject( { mvname="Mv_Null_BattleMain" } );
	}
}

//-----------------------------------------------------------------------------
// 連打コンボ
//-----------------------------------------------------------------------------

t.Mv_Atk_SSRelayAtk <- {};

t.Mv_Atk_RapidFinishAtk <-
{
}

//-----------------------------------------------------------------------------
// 通常技
//-----------------------------------------------------------------------------

t.Mv_Atk_StdA <-
{
	function Init_After()
	{
		// ■レイヤー構造：通常レイヤ(1<<0) / ヒット時レイヤ(1<<1)
		BMvTbl.SetHan6LayerMask( { val = (1<<1) } ); // ヒット時レイヤーは基本的に消しておく
		
		BMvTbl.SetLP(0,0);
		BMvTbl.SetLP(1,2);
		
	}
	function Update_After()
	{
		if( BMvTbl.GetLP(0)>0 )
		{
			BMvTbl.AddLP(0,-1);
			if( BMvTbl.GetLP(0)<=0 )
			{
				BMvTbl.SetHan6LayerMask( { val = (1<<0) } ); // 通常レイヤーを消す
			}
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			//
			BMvTbl.SetLP(0, BMvTbl.GetLP(1) );
		}
	}
	function LastUpdate_After()
	{
		BMvTbl.SetHan6LayerMask( { val = 0 } ); // レイヤーマスクを元に戻す
	}
}

t.Mv_Atk_StdB <-
{
	function Init_After()
	{
	}
}


t.Mv_Atk_StdC <-
{
	function Init_After()
	{
	}
}


t.Mv_Atk_CroA <-
{
	function Init_After()
	{
		// ■レイヤー構造：通常レイヤ(1<<0) / ヒット時レイヤ(1<<1)
		BMvTbl.SetHan6LayerMask( { val = (1<<1) } ); // ヒット時レイヤーは基本的に消しておく
		
		BMvTbl.SetLP(0,0);
		BMvTbl.SetLP(1,2);
	}
	function Update_After()
	{
		if( BMvTbl.GetLP(0)>0 )
		{
			BMvTbl.AddLP(0,-1);
			if( BMvTbl.GetLP(0)<=0 )
			{
				BMvTbl.SetHan6LayerMask( { val = (1<<0) } ); // 通常レイヤーを消す
			}
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			//
			BMvTbl.SetLP(0, BMvTbl.GetLP(1) );
		}
	}
	function LastUpdate_After()
	{
		BMvTbl.SetHan6LayerMask( { val = 0 } ); // レイヤーマスクを元に戻す
	}
}

t.Mv_Atk_CroB <-
{
	function Init_After()
	{
	}
	function HitInterrupt_After()
	{
	}
}

t.Mv_Atk_CroC <-
{
	function Init_After()
	{
	}
}

t.Mv_Atk_AirA <-
{
	function Init_After()
	{
		// ■レイヤー構造：通常レイヤ(1<<0) / ヒット時レイヤ(1<<1)
		BMvTbl.SetHan6LayerMask( { val = (1<<1) } ); // ヒット時レイヤーは基本的に消しておく
		
		BMvTbl.SetLP(0,0);
		BMvTbl.SetLP(1,2);
	}
	function Update_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.Param2 & 4 )
		{
			if( BMvTbl.GetLP(0)>0 )
			{
				BMvTbl.AddLP(0,-1);
				if( BMvTbl.GetLP(0)<=0 )
				{
					BMvTbl.SetHan6LayerMask( { val = (1<<0) } ); // 通常レイヤーを消す
				}
			}
		}
	}
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.Param2 & 4 )
		{
		}
		else
		{
			BMvTbl.SetHan6LayerMask( { val = (1<<1) } ); // ヒット時レイヤーは基本的に消しておく
		}
	}
	function HitInterrupt_After()
	{
		if( Battle_Std.CheckHitTiming() )
		{
			//
			BMvTbl.SetLP(0, BMvTbl.GetLP(1) );
		}
	}
	function LastUpdate_After()
	{
		BMvTbl.SetHan6LayerMask( { val = 0 } ); // レイヤーマスクを元に戻す
	}
}

t.Mv_Atk_AirB <-
{
	function Init_After()
	{
	}
}

t.Mv_Atk_AirC <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		Battle_Std.SetPattern_NotHoldButton( { ButtonMask=(1<<2), CheckFrameID=50, EndFrameID=60, SetPattern="AirC_End" } ); // ボタンホールドしてなかったらパターンジャンプ
	}
}

t.Mv_Atk_Cro3C <- {};

t.Mv_Atk_Std4C <-
{
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100: // ジャンプ
			Battle_Std.StdAtkToAir_AddAirCountPenalty(); //地上から飛び上がってキャンセルできるので空ダ消費
			break;
		}
	}
}

t.Mv_Skill_623BC <-
{
	function Init_After()
	{
		BMvEff.PcAfterImage_Set( { type=1, range=14, delay=2, color=0xFF03A9F4, blendmode=1 } );
		BMvEff.AttackInfoString_Set({word="MOON SKILL"});
	}
	function LastUpdate_After()
	{
		BMvEff.PcAfterImage_Clear()
	}
}


//-----------------------------------------------------------------------------
// 236攻 地上ビーム
//-----------------------------------------------------------------------------
local maketmpl_SkillShotBeam = function( param={} )
{
	local ret_tmpl = {};

	local mvParam =
	{
		ball = 0,
		charge_antenmove = 0,
	}

	switch( param.type )
	{
	case "A":
		mvParam.ball = {
			[100] = { x=190, y=-270, mv="Mv_FireBall_236A", pat="FB_236A" },
		}
		break;
	case "B":
		mvParam.ball = {
			[100] = { x=260, y=-270, mv="Mv_FireBall_236B1", pat="FB_236B" },
			[110] = { x=190, y=-270, mv="Mv_FireBall_236B2", pat="FB_236B" },
		}
		break;
	case "BC":
		mvParam.ball = {
			[100] = { x=260, y=-270, mv="Mv_FireBall_236BC1", pat="FB_236BC" },
			[110] = { x=190, y=-270, mv="Mv_FireBall_236BC2", pat="FB_236BC" },
		}
		break;
	case "EX":
		mvParam.ball = {
			[100] = { x=190, y=-270, mv="Mv_FireBall_236EX1", pat="FB_236EX" },
			[110] = { x=260, y=-270, mv="Mv_FireBall_236EX2", pat="FB_236EX" },
			[120] = { x=190, y=-270, mv="Mv_FireBall_236EX3", pat="FB_236EX" },
			[130] = { x=260, y=-270, mv="Mv_FireBall_236EX4", pat="FB_236EX" },
			[140] = { x=300, y=-220, mv="Mv_FireBall_236EX5", pat="FB_236EX2" }, // フィニッシュ
		}
		mvParam.charge_antenmove = 1;
		break;
	}
	
	ret_tmpl.Init_After <- function() : (mvParam)
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Obj_BeamChageEff" } );
		if( eff.push() )
		{
			if( mvParam.charge_antenmove == 1 ) // 暗転中動く
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetLP(0,1); // 暗転中動くタイプ
			}
			eff.pop();
		}		
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvParam)
	{
		local update_frameid = Battle_Std.GetUpdateFrameID();
		switch( update_frameid )
		{
		case 100:
		case 110:
		case 120:
		case 130:
		case 140:
			if( mvParam.ball && update_frameid in mvParam.ball )
			{
				local ball = Battle_Std.CreateFireBall( mvParam.ball[update_frameid] );
			}
			break;
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function()
	{
	}
	
	ret_tmpl.LastUpdate_After <- function()
	{
	}
	
	return ret_tmpl;

}

t.Mv_Skill_236A <- maketmpl_SkillShotBeam( { type="A" } );
t.Mv_Skill_236B <- maketmpl_SkillShotBeam( { type="B" } );
t.Mv_Skill_236BC <- maketmpl_SkillShotBeam( { type="BC" } );
t.Mv_Skill_236EX <- maketmpl_SkillShotBeam( { type="EX" } );


t.Mv_Obj_BeamChageEff <-
{
	function Init_After()
	{
		// BMvTbl.SetLP(0,0); // 1:暗転中動くタイプ
		BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_EraseParentPatChange } );
	}
	function FrameUpdate_After()
	{
		if( !BtlOb.SetPos_MarkingPlayerEtcRect() )
		{
			BMvTbl.SetFinalize();
		}
		if( BMvTbl.GetLP(0)==1 )
		{
			// この処理は同時暗転のときうまくいかないが、ほとんどわからないので一旦このままに
			local player = BMvCore.GetPlayerCharaData();
			if( player.push() )
			{
				local anten_stop = Battle_Std.MoveCodeEx.CheckFlag( 2, def_MC2_EnemyAntenStop );
				player.pop();
				
				if( anten_stop )
				{
					BMvTbl.JumpFrameID(1); // 止まってる風にする
				}
			}
		}
	}
}

// 派生掌底
t.Mv_Skill_236A_AddA <- {};

// 派生スラ
t.Mv_Skill_236A_AddB <- {
	function HitInterrupt_After()
	{
		// スラなのに持続当てという概念がない
		if( Battle_Std.CheckHitTiming_FrameID(100) )
		{
			BMvTbl.JumpFrameID(200);
		}
	}
};

//-----------------------------------------------------------------------------
// J236攻 空中ビーム
//-----------------------------------------------------------------------------
local maketmpl_SkillAirShotBeam = function( param={} )
{
	local ret_tmpl = {};

	local mvParam =
	{
		ball = 0,
		charge_antenmove = 0,
	}

	switch( param.type )
	{
	case "A":
		mvParam.ball = {
			[100] = { x=130, y=-210, mv="Mv_FireBall_J236A", pat="FB_J236A" },
		}
		break;
	case "B":
		mvParam.ball = {
			[100] = { x=150, y=-220, mv="Mv_FireBall_J236B1", pat="FB_J236B" },
			[110] = { x=130, y=-210, mv="Mv_FireBall_J236B2", pat="FB_J236B2" },
		}
		break;
	case "BC":
		mvParam.ball = {
			[100] = { x=150, y=-220, mv="Mv_FireBall_J236BC1", pat="FB_J236BC" },
			[110] = { x=130, y=-210, mv="Mv_FireBall_J236BC2", pat="FB_J236BC2" },
		}
		break;
	case "EX":
		mvParam.ball = {
			[100] = { x=130, y=-210, mv="Mv_FireBall_J236EX1", pat="FB_J236EX" },
			[110] = { x=150, y=-220, mv="Mv_FireBall_J236EX2", pat="FB_J236EX" },
			[120] = { x=130, y=-210, mv="Mv_FireBall_J236EX2", pat="FB_J236EX" },
			[130] = { x=150, y=-220, mv="Mv_FireBall_J236EX2", pat="FB_J236EX" },
			[140] = { x=130, y=-210, mv="Mv_FireBall_J236EX2", pat="FB_J236EX2" }, // フィニッシュ
		}
		mvParam.charge_antenmove = 1; // 暗転中動くエフェクト
		break;
	}
	
	ret_tmpl.Init_After <- function() : (mvParam)
	{
		local eff = BMvEff.CreateObject( { mvname="Mv_Obj_BeamChageEff" } );
		if( eff.push() )
		{
			if( mvParam.charge_antenmove == 1 ) // 暗転中動く
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_MoveTimeStopAll } );
				BMvTbl.SetLP(0,1); // 暗転中動くタイプ
			}
			eff.pop();
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvParam)
	{
		local update_frameid = Battle_Std.GetUpdateFrameID();
		switch( update_frameid )
		{
		case 100:
		case 110:
		case 120:
		case 130:
		case 140:
			if( mvParam.ball && update_frameid in mvParam.ball )
			{
				local ball = Battle_Std.CreateFireBall( mvParam.ball[update_frameid] );
			}
			break;
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function()
	{
	}
	
	ret_tmpl.LastUpdate_After <- function()
	{
	}
	
	return ret_tmpl;

}

t.Mv_Skill_J236A <- maketmpl_SkillAirShotBeam( { type="A" } );
t.Mv_Skill_J236B <- maketmpl_SkillAirShotBeam( { type="B" } );
t.Mv_Skill_J236BC <- maketmpl_SkillAirShotBeam( { type="BC" } );
t.Mv_Skill_J236EX <- maketmpl_SkillAirShotBeam( { type="EX" } );

t.Mv_FireBall_236A <-
{
	flags=def_FBTmplFlags_NewTypeFireBall,
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
	}
	function Blocked()
	{
		BMvTbl.JumpFrameID(900);
	}
	function Sousai()
	{
		BMvTbl.JumpFrameID(900);
	}
	function HitInterrupt_After() : (set_blackfiredamage)
	{
		set_blackfiredamage();
	}
}

t.Mv_FireBall_236B1 <- t.Mv_FireBall_236A;
t.Mv_FireBall_236B2 <- t.Mv_FireBall_236A;
t.Mv_FireBall_236EX1 <- t.Mv_FireBall_236A;
t.Mv_FireBall_236EX2 <- t.Mv_FireBall_236A;
t.Mv_FireBall_236EX3 <- t.Mv_FireBall_236A;
t.Mv_FireBall_236EX4 <- t.Mv_FireBall_236A;
t.Mv_FireBall_236EX5 <- t.Mv_FireBall_236A;
t.Mv_FireBall_236BC1 <- t.Mv_FireBall_236A;
t.Mv_FireBall_236BC2 <- t.Mv_FireBall_236A;

t.Mv_FireBall_J236A <-
{
	flags=def_FBTmplFlags_NewTypeFireBall,
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
	}
	function Blocked()
	{
		BMvTbl.JumpFrameID(900);
	}
	function Sousai()
	{
		BMvTbl.JumpFrameID(900);
	}
	function HitInterrupt_After() : (set_blackfiredamage)
	{
		set_blackfiredamage();
	}
}



t.Mv_FireBall_J236B1 <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236B2 <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236EX1 <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236EX2 <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236EX3 <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236EX4 <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236EX5 <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236BC1 <- t.Mv_FireBall_J236A;
t.Mv_FireBall_J236BC2 <- t.Mv_FireBall_J236A;

//-----------------------------------------------------------------------------
// 22攻
//-----------------------------------------------------------------------------

local maketmpl_SkillGroundBomb = function( param={} )
{
	local ret_tmpl = {};
	
	local mvParam =
	{
		ball = 0,
	}

	switch( param.type )
	{
	case "EX":
		mvParam.ball = {
			[100] = { x=0, y=0, mv="Mv_FireBall_0202EX", pat="FB_0202EX" },
		}	
		break;
	}	
	
	ret_tmpl.Init_After <- function()
	{
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvParam)
	{
		local update_frameid = Battle_Std.GetUpdateFrameID();
		switch( update_frameid )
		{
		case 100:
			if( mvParam.ball && update_frameid in mvParam.ball )
			{
				local ball = Battle_Std.CreateFireBall( mvParam.ball[update_frameid] );
			}
			break;
		}
	}
	
	return ret_tmpl;	
}


t.Mv_Skill_0202EX <- maketmpl_SkillGroundBomb( { type="EX" } );

t.Mv_FireBall_0202EX <- 
{
	flags=def_FBTmplFlags_NewTypeFireBall,
	function Init_After()
	{
	}
	function FrameUpdate_After()
	{
	}
	function Blocked()
	{
		BMvTbl.JumpFrameID(900);
	}
	function Sousai()
	{
		BMvTbl.JumpFrameID(900);
	}
	function HitInterrupt_After() : (set_blackfiredamage)
	{
		set_blackfiredamage();
	}
}

//-----------------------------------------------------------------------------
// 214攻
//-----------------------------------------------------------------------------


local maketmpl_Skill214 = function( param={} ) : (set_blackfiredamage)
{
	local ret_tmpl = {};
	
	local mvParam =
	{
		move_enemy = 0,
		throw_mv = 0,
		check_furimuki = 0,
		set_guardflag_high = 0,
	}

	switch( param.type )
	{
	case "A":
		mvParam.move_enemy = { power = 50 };
		break;
	case "B":
		break;
	case "EX":
		mvParam.move_enemy = { power = 100 };
		break;
	case "BC":
		mvParam.move_enemy = { power = 50 };
		mvParam.check_furimuki = 1;
		mvParam.set_guardflag_high = 1;
		break;
	}
	
	ret_tmpl.flags <- def_TmplFlags_NoSurinuke;
	
	ret_tmpl.Init_After <- function()
	{
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvParam)
	{
		local mvs = BMvTbl.GetMvStatus();
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 770://振り向きタイミング
			if( mvParam.check_furimuki && BMvTbl.CheckFurimuki() )
			{
				BMvTbl.JumpFrameID(780); // 逆向きの絵にする
			}
			break;
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function() : (mvParam, set_blackfiredamage)
	{
		if( mvParam.move_enemy )
		{
			if( Battle_Std.CheckDamageTiming_ExceptDown() )
			{
				Battle_Std.SetPosition_DamageHanteiRect( mvParam.move_enemy );
			}
		}
		
		//EXのみ ID500
		//エリアルへ行く
		if( Battle_Std.SetImpactHitEffect( { aerial=1, frameid=500, offx=100, offy=-100 } ) ) // 
		{
		}
		
		if( mvParam.set_guardflag_high && Battle_Std.CheckGuardTiming() )
		{
			//一回ガードしたら上段化
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
		
		set_blackfiredamage();
	}
	
	return ret_tmpl;	
}

t.Mv_Skill_214A <- maketmpl_Skill214( { type="A" } );
t.Mv_Skill_214B <- maketmpl_Skill214( { type="B" } );
t.Mv_Skill_214EX <- maketmpl_Skill214( { type="EX" } );
t.Mv_Skill_214BC <- maketmpl_Skill214( { type="BC" } );

t.Mv_Skill_214A_Add <- {
	function HitInterrupt_After() : (set_blackfiredamage)
	{
		if( Battle_Std.CheckDamageTiming_ExceptDown() )
		{
			Battle_Std.SetPosition_DamageHanteiRect( { power = 80 } );
		}
		set_blackfiredamage();
	}
};

t.Mv_Skill_214A_Add_Add <-
{
	function FrameUpdate_After()
	{
		local mvs = BMvTbl.GetMvStatus();
		if( mvs.FrameID == 50 )
		{
			if( Battle_Std.GetEnemyDistance() < 150*128 )
			{
				BMvTbl.JumpFrameID(150);
			}
		}
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50://ダッシュ中
			break;
		case 150://すり抜け開始
			break;
		case 200://攻撃
			// ヒットとか関係なく引き寄せているが、ここにくる＝距離が近い時なのでOK
			if( BtlPl.SetPos_MakeGamenHajiSpace_Enemy( { x=50 } ) ) //端の相手に隙間作る
			{
			}
			else
			{
				// ギリギリのときできないことがある＆背中に判定がないのでもう少し強めに引っ張る処理をいれる
				// SetPos_MakeGamenHajiSpace_Enemyの関数を拡張したいが、今回は影響範囲狭く処理をする

				local epos = Battle_Std.GetEnemyPosition();
				local almost_corner_x = def_POS_GamenHajiX - (8*128); // ほぼ端とする座標
				local enemy_is_almost_corner = ( epos.x >= almost_corner_x || epos.x <= -almost_corner_x )? 1 : 0; // ほぼ端
				
				// 敵がほぼ端付近にいる
				// 敵がboundで地上にいる＝ほぼ地上ガードを想定
				if( enemy_is_almost_corner && Battle_Std.CheckEnemyisBound() && epos.y >=0 )
				{
					local ppos = BMvTbl.GetPosition();
					local enemy = BMvCore.GetEnemyCharaData();
					local muki = ( epos.x > 0 )? -1 : 1; // ステージ中央に動かす
					
					if( enemy.push() )
					{
						BMvTbl.SetPosition( { x=10*muki, flags=( _Position_Add | _Position_CaptureShift ) } );//10ドット引っ張る
						
						enemy.pop();
					}
				}
			}
			break;
		}
	}
	function HitInterrupt_After() : (set_blackfiredamage)
	{
		if( Battle_Std.CheckDamageTiming_ExceptDown() )
		{
			Battle_Std.SetPosition_DamageHanteiRect( { power = 80 } );
		}
		set_blackfiredamage();
	}
}

t.Mv_Skill_214A_Add_Add4 <-
{
	flags = def_TmplFlags_NoSurinuke,
	function Init_After()
	{
		BMvTbl.SetLP(0,0); // ヒットで1
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 200://攻撃
			if( BMvTbl.GetLP(0) == 1 )
			{
				BtlPl.SetPos_MakeGamenHajiSpace_Enemy( { x=50 } );//端の相手に隙間作る
			}
			break;
		case 770://振り向きタイミング
			if( BMvTbl.CheckFurimuki() )
			{
				BMvTbl.JumpFrameID(780); // 逆向きの絵にする
			}
			break;
		}
	}
	function HitInterrupt_After() : (set_blackfiredamage)
	{
		if( Battle_Std.CheckHitTiming() )
		{
			BMvTbl.SetLP(0,1); // ヒットで1
		}
		if( Battle_Std.CheckGuardTiming() )
		{
			//一回ガードしたら上段化
			BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_GuardCrouch|_GuardFlag_GuardAir, time=64, flag=_ClearFlag_ChangeMv } );
		}
		set_blackfiredamage();
	}
}

// コマ投げ
t.Mv_Skill_214A_Add_Add6 <-
{
	function FrameUpdate_After()
	{
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // 投げ
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256, "Mv_Skill_214A_Add_Add_Hit"] ); //デフォ,[code,mv]...	
	}
}

t.Mv_Skill_214A_Add_Add_Hit <- 
{
	function Init_After()
	{
		// 無敵で相手をつかみ開放の初期設定
		Battle_Std.MutekiThrowRelease_Init();
	}
	function FrameUpdate_After()
	{
		// 無敵で相手を掴み開放
		Battle_Std.MutekiThrowRelease( { FrameID=100, x=220, y=0, type="無声ダウン" } );
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			// アッパー
			BMvEff.ThrowChara_SetJoint( 0 ); // 相手を切り離す
			break;
		case 70:
			// 空中でつかむ
			Battle_Std.MakeMv.LastCharaAnimeEnd(1); // アニメ解除ベクトル初期化
			BMvEff.ThrowChara_SetJoint( 1 ); // 相手をくっつける
			break;
		case 100:
			// 開放・叩きつけ着地
			BMvEff.ThrowChara_SetJoint( 0 ); // 相手を切り離す
			break;
		}
	}
}

t.Mv_Skill_214BC <-
{
	function Init_After()
	{
		BMvEff.PcAfterImage_Set( { type=1, range=14, delay=2, color=0xFF03A9F4, blendmode=1 } );
		BMvEff.AttackInfoString_Set({word="MOON SKILL"});
	}
	function LastUpdate_After()
	{
		BMvEff.PcAfterImage_Clear()
	}
}

//-----------------------------------------------------------------------------
// J214攻 空中パンチ
//-----------------------------------------------------------------------------
local maketmpl_SkillAirDashPunch = function( param={} )
{
	local ret_tmpl = {};

	local mvParam =
	{
		ball = 0,
		throw_mv = 0,
		use_airdash = 0,
	}

	switch( param.type )
	{
	case "A":
		mvParam.ball = {
			[100] = { x=0, y=0, mv="Mv_FireBall_J214A", pat="FB_J214A", create_flags=(1<<0) },
		}
		mvParam.use_airdash = 1;
		break;
	case "B":
		mvParam.use_airdash = 1;
		break;
	case "BC":
		break;
	case "EX":
		mvParam.throw_mv = "Mv_Skill_J214EX_Hit";
		break;
	}
	
	ret_tmpl.Init_After <- function() : (mvParam)
	{
		if( mvParam.use_airdash )
		{
			BMvTbl.AddAirCount( def_ACS_AirDash, 1 ); // 空中ダッシュを使った加算
		}
	}
	
	ret_tmpl.FrameUpdate_After <- function() : (mvParam)
	{
		local update_frameid = Battle_Std.GetUpdateFrameID();
		switch( update_frameid )
		{
		case 100:
			if( mvParam.ball && update_frameid in mvParam.ball )
			{
				local ball = Battle_Std.CreateFireBall( mvParam.ball[update_frameid] );
				BMvTbl.SetPosition( { x=-350*128, flags=_Position_Add|_Position_ChangeMuki } );
			}
			break;
		case 110:
			local eff = BMvEff.CreateObject( { start_pat="J214BackDummy", x=-350*128 } );
			if( eff.push() )
			{
				BMvEff.SetObjectFlags( { flags=_ObjFlags_NoGround|_ObjFlags_RenderShadow } );
				eff.pop();
			}
			break;
		}
	}
	
	ret_tmpl.HitInterrupt_After <- function() : (mvParam)
	{
		if( mvParam.throw_mv )
		{
			Battle_Std.SetThrowHitFinalize(256);
		}
	}
	
	if( mvParam.throw_mv )
	{
		ret_tmpl.Finalize <- function() : (mvParam)
		{
			Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,mvParam.throw_mv] ); //デフォ,[code,mv]...	
		}
	}		
	
	return ret_tmpl;

}

t.Mv_Skill_J214A <- maketmpl_SkillAirDashPunch( { type="A" } );
t.Mv_Skill_J214B <- maketmpl_SkillAirDashPunch( { type="B" } );
t.Mv_Skill_J214BC <- maketmpl_SkillAirDashPunch( { type="BC" } );
t.Mv_Skill_J214EX <- maketmpl_SkillAirDashPunch( { type="EX" } );


t.Mv_FireBall_J214A <- 
{
	flags=def_FBTmplFlags_NewTypeFireBall,
	function Init_After()
	{
		BMvEff.SetObjectFlags( { flags=_ObjFlags_ToParentStop } );
		// uniqIDが変わっても消していないので、判定データの調整時は気をつけること
	}
	function FrameUpdate_After()
	{
	}
	function Blocked()
	{
		BMvTbl.JumpFrameID(900);
	}
	function Sousai()
	{
		BMvTbl.JumpFrameID(900);
	}
}

t.Mv_Skill_J214BC <-
{
	function Init_After()
	{
		BMvEff.PcAfterImage_Set( { type=1, range=14, delay=2, color=0xFF03A9F4, blendmode=1 } );
		BMvEff.AttackInfoString_Set({word="MOON SKILL"});
	}
	function LastUpdate_After()
	{
		BMvEff.PcAfterImage_Clear()
	}
}

t.Mv_AniSet_214EX1 <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [320,0,5], },
	{ Data = [320,0,5], Vector={ x=0,y=-6000,addx=0,addy=0,flags=_Vector_Normal }, },
	{ Data = [320,1,7], },
	{ Data = [320,2,7], }
	{ Data = [320,3,5], },
	{ Data = [320,4,5], },
	{ Data = [320,5,5], RelJump = 0 },
] } );

t.Mv_AniSet_214EX2 <- Battle_Std.MakeMv.SetCaptureCharaAnime( { animation = [
	{ Data = [320,3,5], Vector={ x=0,y=4000,addx=0,addy=180,flags=_Vector_Normal }, },
	{ Data = [320,4,7], },
	{ Data = [320,5,5], RelJump = 0 },
] } );

t.Mv_Skill_J214EX_Hit <- {
	function Init_After()
	{
		BMvEff.FadeProc_Set( { type=0, time=[0,1,10] color=0xFFFFFF } ); // ホワイトイン
		
		BMvEff.ThrowChara_SetJoint( 0 ); // 親にくっつけない
		
		BMvEff.FadeProc_Set( { type=1, time=[0,9999,10], color=0x000000 } ); // 
		
		BMvEff.CreateObject( { mvname="Mv_AniSet_214EX1" } );
		
		BMvEff.SetCamera_Clipping( 0 ); //画面端のクリッピング補正を切る
		BMvEff.SetExist( { level = _Exist_NoWall } ); // 画面外で行動する場合があるので壁判定解除
		
		BMvEff.PcAfterImage_Set( { type=1, range=14, delay=2, color=0xDDCCCCFF, blendmode=1 } );

		Battle_Std.MoveCodeEx.AddFlag( 3, def_MC3_SPActionProduction );//超技演出中扱いにしてヒスコハのパートナーとか設置を消す
		BMvEff.SetObjectRender( { type=2 } );// _ObjFlags_NoRenderOrder属性のある全てのオブジェクトを非表示
	}
	function FrameUpdate_After()
	{
		Battle_Std.MutekiThrowRelease( { FrameID=500, x=-250, y=-250, type="無声ダウン" } );
		
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 50:
			// ヒット後ちょっとたって自分も相手も来たら位置をいい感じのところにしてごまかす
			// 端近いときは中央に移動する
			BtlPl.SetPos_ExcessGamenHajiX( { off_x = 200*128 } );

			BMvTbl.SetPosition( { y=-300*128 } );
			BMvEff.ThrowParam( { pattern=320, x=0, y=-1000 } );

			// カメラ位置をリセット
			local pos = BMvTbl.GetPosition();
			BMvEff.SetCamera_Focus( { x=pos.x, y=-180*128, zoom=1.0, time=[0,999,30], type_in=1 } );//浮いてるのでここで良い
			
			BMvEff.CreateObject( { mvname="Mv_AniSet_214EX2" } );

			BMvTbl.SetPosition( { x=500*128, flags=_Position_Add|_Position_ChangeMuki } );
			break;
		case 100:
			// 突撃
			BMvEff.SetCamera_Focus( { time=[0,0,10], type_out=1 } ); // 端であてたときステージ外が見えるので注意
			BMvEff.CameraShift_Set( { y=-150*128 } );
			
			Battle_Std.MakeMv.LastCharaAnimeEnd(1);
			local enemy = BMvCore.GetEnemyCharaData();
			if( enemy.push() )
			{
				BMvTbl.SetPattern(320); // 絵だけ変更
				BMvTbl.SetMuki(_Direction_Reverse);
				enemy.pop();
			}
			break;
		case 150:
			// 突撃２
			// 相手は動かない
			break;
		case 200:
			// フィニッシュ1F前
			BMvEff.SetExist( { level = _Exist_NoWall, mode=_ExistMode_Erase } ); // 画面外で行動する場合があるので壁判定解除を戻す
			BMvEff.SetCamera_Clipping( 1 ); //画面端のクリッピング補正を戻す
			break;
		case 500:
			// フィニッシュ
			BMvEff.FadeProc_Set( { type=1, time=[0,25,10] color=0x000000 } ); // 25Fぐらいないとステージ外が見える
			Battle_Std.MoveCodeEx.DelFlag( 3, def_MC3_SPActionProduction );//もとに戻す
			BMvEff.SetObjectRender( { type=0 } );//もとに戻す
			BMvEff.PcAfterImage_ClearEx(1); //残像の消去
			break;
		}
	}
	function HitInterrupt_After() : (set_blackfiredamage)
	{
		set_blackfiredamage();
	}
	function LastUpdate_After()
	{
		BMvEff.FadeProc_Set( { type=1, time=[0,0,10] color=0x000000 } ); // 
		BMvEff.CameraShift_Clear();
		BMvEff.SetObjectRender( { type=0 } );//もとに戻す
		BMvEff.PcAfterImage_ClearEx()
	}
};

t.Mv_Skill_41236SP <-
{
	function Init_After()
	{
		// コンボ中は空振り設定を無視するがダウン中は空振りのままにする
		BMvTbl.SetAtkGuardFlag( { guard=_GuardFlag_ThroughRemoveDamage|_GuardFlag_ThroughRemoveDamagePlus, time=254, flag=_ClearFlag_ChangeMv } );
		BMvTbl.SetHitCheckFlag( { type=1, val=Def_HitCheckFlag_Down, time=254, flag=_ClearFlag_ChangeMv } ); // スカる
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			break;
		}
	}
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256);
	}
	function Finalize()
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral", [256,"Mv_Skill_41236SP_Hit"] ); //デフォ,[code,mv]...	
	}
}

t.Mv_Skill_41236SP_Hit <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		Battle_Std.InitArcDriveHit();
		
		//超技つかみのテンプレ
		BMvEff.ThrowChara_SetCamera( 1 ); //投げているキャラをカメラ処理に含めるかどうか
		BMvEff.SetCamera_Clipping( 0 ); //画面端のクリッピング補正を切る
		BMvEff.ThrowChara_SetJoint( 0 ); // 親にくっつけない
		BMvEff.SetExist( { level = _Exist_NoWall } ); // 画面外で行動する場合があるので壁判定解除
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			break;
		case 500:
            // 叩きつける
            BMvEff.SetCamera_Focus( { zoom=0.8, time=[10,999,30] } );
			BMvEff.ThrowRelease( { type="追撃ダウン", airrecover=0, flags=_ThrowRelease_NoGroundRecover|_ThrowRelease_NoWallRecover } );
            break;
		case 600:
			break;
		case 700:
			break;
		case 800:
			// スロー的な余韻
			BMvEff.FadeProc_Set( { type=0, time=[35,999,0] color=0xFFFFFF } ); // 
			break;
		}
	}
	function HitInterrupt_After()
	{
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_41236SP_End" );
	}
	function LastUpdate_After()
	{
		BMvEff.SetCamera_Focus( { time=[0,0,10], type_out=1 } );
		BMvEff.FadeProc_Set( { type=0, time=[0,0,30] color=0xFFFFFF } ); // 
		Battle_Std.ClearSPLockCamera( { flags=(1<<0) } );
		Battle_Std.LastUpdateArcDriveHit();
		
		//つかみ開放
		BMvEff.ThrowParam( { pattern=324, x=300, y=-300, } );
		//つかみ開放
		BMvEff.ThrowRelease( { type="腹吹き飛び", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
	}
}

t.Mv_Skill_41236SP_End <- 
{
	flags = def_TmplFlags_NoAddComboRate|def_TmplFlags_NoFurimuki // コンボレートを加算しない＆振り向かない
	function Init_After()
	{
		Battle_Std.MvAction.AddFlag( def_MC_NoBursted ); // バーストされない行動
		BMvEff.ThrowParam( { pattern=324, x=300, y=-400, } );
		BMvEff.ThrowRelease( { type="斜め下バウンド", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
	}
	function LastUpdate_After()
	{
	}
}

t.Mv_Skill_SSRelayAtk <- {};

//-----------------------------------------------------------------------------
// インフィニットワースＥＸＳ
//-----------------------------------------------------------------------------

t.Mv_Skill_IWEXIST <- 
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function HitInterrupt_After()
	{
		Battle_Std.SetThrowHitFinalize(256); // ヒット分岐ファイナライズ
	}
	function Finalize() // 
	{
		Battle_Std.SwitchNextMoveTable("Mv_Neutral",[256,"Mv_Skill_IWEXIST_Hit"]); //デフォ,[code,mv]...
	}	
}

t.Mv_Skill_IWEXIST_Hit <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function EnemyRelease()
	{
		BMvEff.ThrowParam( { pattern=324 x=320, y=-400 } );
		BMvEff.ThrowRelease( { type="斜め下バウンド", airrecover=0, flags=_ThrowRelease_NoAttackHit|_ThrowRelease_NoGroundRecover } );
	}
	function SetEnemyCharaScale( scale=10000 )
	{
		local enemy = BMvCore.GetEnemyCharaData();
		if( enemy.push() )
		{
			BMvTbl.SetScale( { x=scale, y=scale } );
			
			enemy.pop();
		}
	}
	function Init_After()
	{
		
		Battle_Std.InitIWExistSkill();
		BMvEff.Cockpit_SetView( { mode=0 } );
		
		BMvEff.ThrowChara_SetJoint( 0 ); // 切り離す
		BMvEff.ThrowChara_SetCamera( 0 ); // 相手をカメラにふくめる
	}
	function FrameUpdate_After()
	{
		switch( Battle_Std.GetUpdateFrameID() )
		{
		case 100:
			// 横にダッシュ
			BSound.BGM_SetFade( { val=50, time=240 } );//BGMのフェードアウト
			break;
		case 200:
			// 高速移動開始
			break;
		case 300:
			// ぶつかって飛び散る
			// 相手縮小
			SetEnemyCharaScale(7500);
			break;
		case 400:
			// 一斉にビーム
			SetEnemyCharaScale(5000);
			BSound.BGM_SetFade( { val=25, time=240 } );//BGMのフェードアウト
			break;
		case 900:
			//ホワイトアウトして終わり
			BMvEff.FadeProc_Set( { type=0, time=[20,999,0] color=0xFFFFFF } ); // 
			break;
		}
	}
	function Finalize()
	{
		BMvTbl.SetNextMoveTable( "Mv_Skill_IWEXIST_End" );
	}
	function LastUpdate_After()
	{
		SetEnemyCharaScale(); // 初期化
		
		EnemyRelease();
		
		BSound.BGM_SetFade( { val=100, time=240 } );//BGMのフェードアウト
		Battle_Std.ClearSPLockCamera( { flags=(1<<0), pos={ player={ x=-320, y=0 }, enemy={ x=320, y=-400 } } } );
		BMvEff.FadeProc_SetRenderFlag(0);
	}
}

t.Mv_Skill_IWEXIST_End <-
{
	flags = def_TmplFlags_NoAddComboRate // コンボレートを加算しない
	function Init_After()
	{
		Battle_Std.MvAction.AddFlag( def_MC_NoBursted ); // バーストされない行動
		Battle_Std.FinalizeIWExistSkill();
	}
};

DANTES_MoveTable <- Battle_Std.MakeMoveTable( t, DANTES_CommandTable, Def_ChrNo_Dan ); // Registers the table
__dofile__("./data/Dantes/Dantes_se_category.txt"); // Pulls up the audio mappings
